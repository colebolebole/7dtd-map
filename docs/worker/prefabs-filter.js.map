{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/prefabs.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(o: unknown, t: new (...a: unknown[]) => T, errorMessage = () => `Unexpected type: ${String(o)}`): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: GameMapSize,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords, mapSize: GameMapSize) => number | null,\n  event: EventOffsets | null,\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  const y = elevation(gameCoords, map) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function imageBitmapToPngBlob(img: ImageBitmap): Promise<PngBlob> {\n  const canvas = new OffscreenCanvas(img.height, img.width);\n  const context = requireNonnull(canvas.getContext(\"2d\"));\n  context.drawImage(img, 0, 0);\n  return (await canvas.convertToBlob({ type: \"image/png\" })) as PngBlob;\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  return (await (await fetch(url)).json()) as T;\n}\n\nexport async function invokeAll<T>(fns: ((t: T) => unknown)[], t: T): Promise<void> {\n  await Promise.all(fns.map((fn) => fn(t)));\n}\n", "import { sleep } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void, intervalMs = 100): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await sleep(intervalMs);\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { printError } from \"./utils\";\n\nexport interface PrefabUpdate {\n  status: string;\n  prefabs: HighlightedPrefab[];\n}\n\nexport default class Prefabs {\n  #labelHolder: LabelHolder;\n\n  #filtered: HighlightedPrefab[] = [];\n  #status = \"\";\n\n  all: Prefab[] = [];\n  markCoords: GameCoords | null = null;\n  difficulty: NumberRange = { start: 0, end: 5 };\n  prefabFilterRegexp = \"\";\n  blockFilterRegexp = \"\";\n  blockPrefabCounts: BlockPrefabCounts = {};\n\n  private throttledUpdater = throttledInvoker(() => this.updateImmediately());\n  private updateListeners: ((u: PrefabUpdate) => void)[] = [];\n\n  constructor(labelsBaseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#labelHolder = new LabelHolder(labelsBaseUrl, navigatorLanguages);\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  update(): void {\n    this.throttledUpdater().catch(printError);\n  }\n  async updateImmediately(): Promise<void> {\n    await this.#applyFilter();\n    this.#updateStatus();\n    this.#updateDist();\n    this.#sort();\n    const update: PrefabUpdate = { status: this.#status, prefabs: this.#filtered };\n    this.updateListeners.forEach((f) => {\n      f(update);\n    });\n  }\n\n  #updateStatus() {\n    if (\n      this.prefabFilterRegexp.length === 0 &&\n      this.blockFilterRegexp.length === 0 &&\n      this.difficulty.start === 0 &&\n      this.difficulty.end === 5\n    ) {\n      this.#status = \"All prefabs\";\n    } else if (this.#filtered.length === 0) {\n      this.#status = \"No prefabs matched\";\n    } else {\n      this.#status = `${this.#filtered.length.toString()} prefabs matched`;\n    }\n  }\n\n  addUpdateListener(func: (update: PrefabUpdate) => void): void {\n    this.updateListeners.push(func);\n  }\n\n  async #applyFilter() {\n    let result = this.#matchByDifficulty(this.all);\n    result = await this.#matchByPrefabName(result);\n    result = await this.#matchByBlockName(result);\n    this.#filtered = result;\n  }\n\n  #matchByDifficulty(prefabs: Prefab[]): Prefab[] {\n    return prefabs.filter((p) => {\n      const d = p.difficulty ?? 0;\n      return d >= this.difficulty.start && d <= this.difficulty.end;\n    });\n  }\n\n  async #matchByPrefabName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    const labels = await this.#labelHolder.get(\"prefabs\");\n    const pattern = new RegExp(this.prefabFilterRegexp, \"i\");\n    return prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const label = labels.get(prefab.name);\n      if (this.prefabFilterRegexp.length === 0) {\n        return {\n          ...prefab,\n          highlightedName: prefab.name,\n          highlightedLabel: label ?? \"-\",\n        };\n      }\n\n      const highlightedName = matchAndHighlight(prefab.name, pattern);\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName != null || highlightedLabel != null) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label ?? \"-\",\n        };\n      }\n\n      return [];\n    });\n  }\n\n  async #matchByBlockName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    if (this.blockFilterRegexp.length === 0) {\n      return prefabs;\n    }\n    const matchedPrefabNames = await this.#matchPrefabTypesByBlockName(prefabs);\n    return prefabs.flatMap((prefab) => {\n      const matchedBlocks = matchedPrefabNames[prefab.name];\n      return matchedBlocks ? { ...prefab, matchedBlocks } : [];\n    });\n  }\n\n  async #matchPrefabTypesByBlockName(prefabs: Prefab[]) {\n    const blockLabels = await this.#labelHolder.get(\"blocks\");\n    const shapeLabels = await this.#labelHolder.get(\"shapes\");\n    const prefabNames = new Set(prefabs.map((p) => p.name));\n    const matchedPrefabNames: { [prefabName: string]: HighlightedBlock[] } = {};\n    const pattern = new RegExp(this.blockFilterRegexp, \"i\");\n    for (const [blockName, prefabs] of Object.entries(this.blockPrefabCounts)) {\n      const highlightedName = matchAndHighlight(blockName, pattern);\n      const label = blockLabels.get(blockName) ?? shapeLabels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName == null && highlightedLabel == null) continue;\n      for (const [prefabName, count] of Object.entries(prefabs)) {\n        if (!prefabNames.has(prefabName)) continue;\n        matchedPrefabNames[prefabName] = (matchedPrefabNames[prefabName] ?? []).concat({\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          count,\n        });\n      }\n    }\n    return matchedPrefabNames;\n  }\n\n  #updateDist() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.#filtered.forEach((p) => (p.dist = calcDist(p, markCoords)));\n    } else {\n      this.#filtered.forEach((p) => (p.dist = null));\n    }\n  }\n\n  #sort() {\n    if (this.#filtered.length === 0) {\n      this.#status += \". Please relax the filter conditions\";\n    } else if (this.markCoords) {\n      this.#status += \", order by distances from the flag\";\n      this.#filtered.sort(distSorter);\n    } else if (this.blockFilterRegexp.length > 0) {\n      this.#status += \", order by counts of matched blocks\";\n      this.#filtered.sort(blockCountSorter);\n    } else {\n      this.#filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string }, b: { name: string }) {\n  if (a.name > b.name) return 1;\n  if (a.name < b.name) return -1;\n  return 0;\n}\n\nfunction blockCountSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.matchedBlocks || !b.matchedBlocks) return nameSorter(a, b);\n  const aCount = a.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  const bCount = b.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  if (aCount < bCount) return 1;\n  if (aCount > bCount) return -1;\n  return nameSorter(a, b);\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.dist || !b.dist) return nameSorter(a, b);\n  if (a.dist > b.dist) return 1;\n  if (a.dist < b.dist) return -1;\n  return nameSorter(a, b);\n}\n\nfunction calcDist(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n", "import Prefabs from \"../lib/prefabs\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<\n  Pick<Prefabs, \"all\" | \"difficulty\" | \"prefabFilterRegexp\" | \"blockFilterRegexp\" | \"markCoords\" | \"language\">\n>;\n\nconst prefabs = new Prefabs(\"../labels\", navigator.languages);\n(async () => {\n  prefabs.blockPrefabCounts = invertCounts(await fetchJson(\"../prefab-block-counts.json\"));\n  prefabs.update();\n})().catch(printError);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update();\n};\n\nprefabs.addUpdateListener((u) => {\n  console.log(\"Prefab-filter send message: \", u);\n  postMessage(u);\n});\n\nfunction invertCounts(counts: PrefabBlockCounts): BlockPrefabCounts {\n  const blockPrefabCounts: BlockPrefabCounts = {};\n  for (const [prefabName, blockCounts] of Object.entries(counts))\n    for (const [blockName, count] of Object.entries(blockCounts))\n      blockPrefabCounts[blockName] = Object.assign(blockPrefabCounts[blockName] ?? {}, { [prefabName]: count });\n  return blockPrefabCounts;\n}\n"],
  "mappings": "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",
  "names": ["sleep", "msec", "r", "printError", "e", "fetchJson", "url", "throttledInvoker", "asyncFunc", "intervalMs", "workerPromises", "p", "prev", "sleep", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "Prefabs", "#labelHolder", "#filtered", "#status", "throttledInvoker", "labelsBaseUrl", "navigatorLanguages", "LabelHolder", "lang", "printError", "#applyFilter", "#updateStatus", "#updateDist", "#sort", "update", "f", "func", "result", "#matchByDifficulty", "#matchByPrefabName", "#matchByBlockName", "prefabs", "p", "d", "labels", "pattern", "prefab", "label", "highlightedName", "matchAndHighlight", "highlightedLabel", "matchedPrefabNames", "#matchPrefabTypesByBlockName", "matchedBlocks", "blockLabels", "shapeLabels", "prefabNames", "blockName", "prefabName", "count", "markCoords", "calcDist", "distSorter", "blockCountSorter", "nameSorter", "a", "b", "aCount", "acc", "bCount", "targetCoords", "baseCoords", "str", "regex", "isMatched", "highlighted", "m", "prefabs", "Prefabs", "invertCounts", "fetchJson", "printError", "data", "u", "counts", "blockPrefabCounts", "prefabName", "blockCounts", "blockName", "count"]
}
