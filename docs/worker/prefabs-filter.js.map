{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/cache-holder.ts", "../../src/lib/prefabs.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { sleep } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void, intervalMs = 100): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  let lastInvokationAt = 0;\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          const now = Date.now();\n          if (now < lastInvokationAt + intervalMs) await sleep(lastInvokationAt + intervalMs - now);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await sleep(intervalMs);\n          lastInvokationAt = Date.now();\n          try {\n            await asyncFunc();\n          } finally {\n            void workerPromises.shift();\n          }\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "const NO_VALUE = Symbol(\"NO_VALUE\");\ntype NoValue = typeof NO_VALUE;\n\n/**\n * A holder for a cached value.\n *\n * The cache is invalidated after `age` since the last access.\n */\nexport class CacheHolder<T> {\n  #fetcher: () => Promise<T>;\n  #deconstructor: (value: T) => unknown;\n  #age: number;\n\n  #value: T | NoValue = NO_VALUE;\n  #fetchPromise: Promise<T> | null = null;\n  #expirationTimeout: ReturnType<typeof setTimeout> | null = null;\n  #lastInvalidation = Date.now();\n\n  constructor(fetcher: () => Promise<T>, deconstructor: (value: T) => unknown, age = 10000) {\n    this.#fetcher = fetcher;\n    this.#deconstructor = deconstructor;\n    this.#age = age;\n  }\n\n  /**\n   * Get the value from the cache.\n   *\n   * If the value is not in the cache, it is fetched and stored.\n   */\n  async get(): Promise<T> {\n    try {\n      return this.#value === NO_VALUE ? await this.#fetch() : this.#value;\n    } finally {\n      this.#resetTimer();\n    }\n  }\n\n  async #fetch() {\n    if (this.#fetchPromise) return this.#fetchPromise;\n    this.#fetchPromise = this.#fetchUntilNoInvalidation();\n    try {\n      this.#value = await this.#fetchPromise;\n    } finally {\n      this.#fetchPromise = null;\n    }\n    return this.#value;\n  }\n\n  async #fetchUntilNoInvalidation(): Promise<T> {\n    let now: number;\n    let value: T;\n    do {\n      now = Date.now();\n      value = await this.#fetcher();\n    } while (now < this.#lastInvalidation);\n    return value;\n  }\n\n  /**\n   * Invalidate the cache.\n   */\n  invalidate() {\n    if (this.#value !== NO_VALUE) {\n      this.#deconstructor(this.#value);\n      this.#value = NO_VALUE;\n    }\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = null;\n    this.#lastInvalidation = Date.now();\n  }\n\n  #resetTimer() {\n    if (this.#expirationTimeout) clearTimeout(this.#expirationTimeout);\n    this.#expirationTimeout = setTimeout(() => {\n      this.invalidate();\n    }, this.#age);\n  }\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { CacheHolder } from \"./cache-holder\";\n\nexport interface PrefabUpdate {\n  status: string;\n  prefabs: HighlightedPrefab[];\n}\n\nexport class PrefabFilter {\n  #labelHolder: LabelHolder;\n  #blockPrefabCountsHolder: CacheHolder<BlockPrefabCounts>;\n\n  #filtered: HighlightedPrefab[] = [];\n  #status = \"\";\n  #updateListeners: ((u: PrefabUpdate) => void)[] = [];\n\n  all: Prefab[] = [];\n  markCoords: GameCoords | null = null;\n  difficulty: NumberRange = { start: 0, end: 5 };\n  prefabFilterRegexp = \"\";\n  blockFilterRegexp = \"\";\n\n  constructor(labelsBaseUrl: string, navigatorLanguages: readonly string[], fetchPrefabBlockCounts: () => Promise<BlockPrefabCounts>) {\n    this.#labelHolder = new LabelHolder(labelsBaseUrl, navigatorLanguages);\n    this.#blockPrefabCountsHolder = new CacheHolder(fetchPrefabBlockCounts, () => {\n      /* do nothing */\n    });\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  update = throttledInvoker(() => this.updateImmediately());\n  async updateImmediately(): Promise<void> {\n    await this.#applyFilter();\n    this.#updateStatus();\n    this.#updateDist();\n    this.#sort();\n    const update: PrefabUpdate = { status: this.#status, prefabs: this.#filtered };\n    this.#updateListeners.forEach((f) => {\n      f(update);\n    });\n  }\n\n  #updateStatus() {\n    if (\n      this.prefabFilterRegexp.length === 0 &&\n      this.blockFilterRegexp.length === 0 &&\n      this.difficulty.start === 0 &&\n      this.difficulty.end === 5\n    ) {\n      this.#status = `All ${this.all.length.toString()} prefabs`;\n    } else if (this.#filtered.length === 0) {\n      this.#status = \"No prefabs matched\";\n    } else {\n      this.#status = `${this.#filtered.length.toString()} prefabs matched`;\n    }\n  }\n\n  addUpdateListener(func: (update: PrefabUpdate) => void): void {\n    this.#updateListeners.push(func);\n  }\n\n  async #applyFilter() {\n    let result = this.#matchByDifficulty(this.all);\n    result = await this.#matchByPrefabName(result);\n    result = await this.#matchByBlockName(result);\n    this.#filtered = result;\n  }\n\n  #matchByDifficulty(prefabs: Prefab[]): Prefab[] {\n    return prefabs.filter((p) => {\n      const d = p.difficulty ?? 0;\n      return d >= this.difficulty.start && d <= this.difficulty.end;\n    });\n  }\n\n  async #matchByPrefabName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    const labels = await this.#labelHolder.get(\"prefabs\");\n    const pattern = new RegExp(this.prefabFilterRegexp, \"i\");\n    return prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const label = labels.get(prefab.name);\n      if (this.prefabFilterRegexp.length === 0) {\n        return {\n          ...prefab,\n          highlightedName: prefab.name,\n          highlightedLabel: label ?? \"-\",\n        };\n      }\n\n      const highlightedName = matchAndHighlight(prefab.name, pattern);\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName != null || highlightedLabel != null) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label ?? \"-\",\n        };\n      }\n\n      return [];\n    });\n  }\n\n  async #matchByBlockName(prefabs: Prefab[]): Promise<HighlightedPrefab[]> {\n    if (this.blockFilterRegexp.length === 0) {\n      return prefabs;\n    }\n    const matchedPrefabNames = await this.#matchPrefabTypesByBlockName(prefabs);\n    return prefabs.flatMap((prefab) => {\n      const matchedBlocks = matchedPrefabNames[prefab.name];\n      return matchedBlocks ? { ...prefab, matchedBlocks } : [];\n    });\n  }\n\n  async #matchPrefabTypesByBlockName(prefabs: Prefab[]) {\n    const blockLabels = await this.#labelHolder.get(\"blocks\");\n    const shapeLabels = await this.#labelHolder.get(\"shapes\");\n    const prefabNames = new Set(prefabs.map((p) => p.name));\n    const matchedPrefabNames: { [prefabName: string]: HighlightedBlock[] } = {};\n    const pattern = new RegExp(this.blockFilterRegexp, \"i\");\n    for (const [blockName, prefabs] of Object.entries(await this.#blockPrefabCountsHolder.get())) {\n      const highlightedName = matchAndHighlight(blockName, pattern);\n      const label = blockLabels.get(blockName) ?? shapeLabels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, pattern);\n      if (highlightedName == null && highlightedLabel == null) continue;\n      for (const [prefabName, count] of Object.entries(prefabs)) {\n        if (!prefabNames.has(prefabName)) continue;\n        matchedPrefabNames[prefabName] = (matchedPrefabNames[prefabName] ?? []).concat({\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          count,\n        });\n      }\n    }\n    return matchedPrefabNames;\n  }\n\n  #updateDist() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.#filtered.forEach((p) => (p.dist = calcDist(p, markCoords)));\n    } else {\n      this.#filtered.forEach((p) => (p.dist = null));\n    }\n  }\n\n  #sort() {\n    if (this.all.length === 0) {\n      this.#status = \"No prefabs loaded\";\n    } else if (this.#filtered.length === 0) {\n      this.#status += \". Please relax the filter conditions\";\n    } else if (this.markCoords) {\n      this.#status += \", order by distances from the flag\";\n      this.#filtered.sort(distSorter);\n    } else if (this.blockFilterRegexp.length > 0) {\n      this.#status += \", order by counts of matched blocks\";\n      this.#filtered.sort(blockCountSorter);\n    } else {\n      this.#filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string }, b: { name: string }) {\n  if (a.name > b.name) return 1;\n  if (a.name < b.name) return -1;\n  return 0;\n}\n\nfunction blockCountSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.matchedBlocks || !b.matchedBlocks) return nameSorter(a, b);\n  const aCount = a.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  const bCount = b.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  if (aCount < bCount) return 1;\n  if (aCount > bCount) return -1;\n  return nameSorter(a, b);\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.dist || !b.dist) return nameSorter(a, b);\n  if (a.dist > b.dist) return 1;\n  if (a.dist < b.dist) return -1;\n  return nameSorter(a, b);\n}\n\nfunction calcDist(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n", "import { PrefabFilter } from \"../lib/prefabs\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<\n  Pick<PrefabFilter, \"all\" | \"difficulty\" | \"prefabFilterRegexp\" | \"blockFilterRegexp\" | \"markCoords\" | \"language\">\n>;\n\nconst prefabs = new PrefabFilter(\"../labels\", navigator.languages, async () =>\n  invertCounts(await fetchJson(\"../prefab-block-counts.json\")),\n);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update().catch(printError);\n};\n\nprefabs.addUpdateListener((u) => {\n  console.log(\"Prefab-filter send message: \", u);\n  postMessage(u);\n});\n\nfunction invertCounts(counts: PrefabBlockCounts): BlockPrefabCounts {\n  const blockPrefabCounts: BlockPrefabCounts = {};\n  for (const [prefabName, blockCounts] of Object.entries(counts))\n    for (const [blockName, count] of Object.entries(blockCounts))\n      blockPrefabCounts[blockName] = Object.assign(blockPrefabCounts[blockName] ?? {}, { [prefabName]: count });\n  return blockPrefabCounts;\n}\n"],
  "mappings": "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",
  "names": ["prefabs", "b"]
}
