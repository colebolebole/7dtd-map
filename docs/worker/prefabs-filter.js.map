{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/prefabs.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t != null) return t;\n  else throw Error(errorMessage());\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(o: unknown, t: new (...a: unknown[]) => T, errorMessage = () => `Unexpected type: ${String(o)}`): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: GameMapSize,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords, mapSize: GameMapSize) => number | null,\n  event: EventOffsets | null,\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  const y = elevation(gameCoords, map) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function imageBitmapToPngBlob(img: ImageBitmap): Promise<PngBlob> {\n  const canvas = new OffscreenCanvas(img.height, img.width);\n  const context = requireNonnull(canvas.getContext(\"2d\"));\n  context.drawImage(img, 0, 0);\n  return (await canvas.convertToBlob({ type: \"image/png\" })) as PngBlob;\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  return (await (await fetch(url)).json()) as T;\n}\n\nexport async function invokeAll<T>(fns: ((t: T) => unknown)[], t: T): Promise<void> {\n  await Promise.all(fns.map((fn) => fn(t)));\n}\n", "import { waitAnimationFrame } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await waitAnimationFrame();\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "export const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  private baseUrl: string;\n  private defaultBlocks: Promise<Map<string, string>>;\n  private defaultPrefabs: Promise<Map<string, string>>;\n\n  #language: Language;\n  #blocks: Promise<Labels>;\n  #prefabs: Promise<Labels>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.defaultBlocks = this.fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, \"blocks.json\");\n    this.defaultPrefabs = this.fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, \"prefabs.json\");\n    this.#blocks = this.buildLabels(this.defaultBlocks, \"blocks.json\");\n    this.#prefabs = this.buildLabels(this.defaultPrefabs, \"prefabs.json\");\n  }\n\n  get blocks(): Promise<Labels> {\n    return this.#blocks;\n  }\n\n  get prefabs(): Promise<Labels> {\n    return this.#prefabs;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#blocks = this.buildLabels(this.defaultBlocks, \"blocks.json\");\n    this.#prefabs = this.buildLabels(this.defaultPrefabs, \"prefabs.json\");\n  }\n\n  async buildLabels(defaultLabels: Promise<Map<string, string>>, fileName: string): Promise<Labels> {\n    return new Labels(await this.fetchLabelMap(this.#language, fileName), await defaultLabels);\n  }\n\n  async fetchLabelMap(language: Language, fileName: string): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson<Labels>(`${this.baseUrl}/${language}/${fileName}`)));\n  }\n}\n\nexport class Labels {\n  labels: Map<string, string>;\n  defaultLabels: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.labels = labels;\n    this.defaultLabels = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.labels.get(key) ?? this.defaultLabels.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n\nasync function fetchJson<T>(path: string): Promise<T> {\n  return (await fetch(path)).json() as T;\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { printError } from \"./utils\";\n\nexport interface PrefabUpdate {\n  status: string;\n  prefabs: HighlightedPrefab[];\n}\n\ninterface PrefabHighlightedBlocks {\n  [prefabName: string]: HighlightedBlock[];\n}\n\nexport default class Prefabs {\n  all: Prefab[] = [];\n  filtered: HighlightedPrefab[] = [];\n  markCoords: GameCoords | null = null;\n  status = \"\";\n\n  #blockPrefabIndex: BlockPrefabIndex = {};\n  #labelHolder: LabelHolder;\n  filter: PrefabMatcher;\n\n  private throttledUpdater = throttledInvoker(() => this.updateImmediately());\n  private updateListeners: ((u: PrefabUpdate) => void)[] = [];\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#labelHolder = new LabelHolder(baseUrl, navigatorLanguages);\n    this.filter = this.defaultMatcher();\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  set prefabsFilterString(filter: string) {\n    const s = filter.trim();\n    if (s.length === 0) {\n      this.filter = this.defaultMatcher();\n    } else {\n      this.filter = new PrefabNameMatcher(new RegExp(s, \"i\"), this.#labelHolder);\n    }\n  }\n  set blocksFilterString(filter: string) {\n    const s = filter.trim();\n    if (s.length === 0) {\n      this.filter = this.defaultMatcher();\n    } else {\n      this.filter = new BlockNameMatcher(new RegExp(s, \"i\"), this.#blockPrefabIndex, this.#labelHolder);\n    }\n  }\n\n  set blockPrefabIndex(index: BlockPrefabIndex) {\n    this.#blockPrefabIndex = index;\n    if (this.filter instanceof BlockNameMatcher) {\n      this.filter = new BlockNameMatcher(this.filter.regexp, index, this.#labelHolder);\n    }\n  }\n\n  update(): void {\n    this.throttledUpdater().catch(printError);\n  }\n  async updateImmediately(): Promise<void> {\n    await this.applyFilter();\n    this.updateDist();\n    this.sort();\n    const update: PrefabUpdate = { status: this.status, prefabs: this.filtered };\n    this.updateListeners.forEach((f) => {\n      f(update);\n    });\n  }\n\n  addUpdateListener(func: (update: PrefabUpdate) => void): void {\n    this.updateListeners.push(func);\n  }\n\n  private defaultMatcher() {\n    return new AllMatcher(this.#labelHolder);\n  }\n\n  private async applyFilter() {\n    const result = await this.filter.match(this.all);\n    this.status = result.status;\n    this.filtered = result.matched;\n  }\n\n  private updateDist() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.filtered.forEach((p) => (p.dist = calcDist(p, markCoords)));\n    } else {\n      this.filtered.forEach((p) => (p.dist = null));\n    }\n  }\n\n  private sort() {\n    if (this.markCoords) {\n      this.status = `${this.status}, order by distances from the flag`;\n      this.filtered.sort(distSorter);\n    } else {\n      this.filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string }, b: { name: string }) {\n  if (a.name > b.name) return 1;\n  if (a.name < b.name) return -1;\n  return 0;\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.dist || !b.dist) return nameSorter(a, b);\n  if (a.dist > b.dist) return 1;\n  if (a.dist < b.dist) return -1;\n  return nameSorter(a, b);\n}\n\nfunction calcDist(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n\ninterface PrefabMatcher {\n  match(prefabs: Prefab[]): Promise<PrefabMatcherResult>;\n}\ninterface PrefabMatcherResult {\n  status: string;\n  matched: HighlightedPrefab[];\n}\n\nclass AllMatcher implements PrefabMatcher {\n  labels: LabelHolder;\n\n  constructor(labels: LabelHolder) {\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const labels = await this.labels.prefabs;\n    return {\n      status: prefabs.length === 0 ? \"No prefabs\" : \"All prefabs\",\n      matched: prefabs.map((p) => {\n        const label = labels.get(p.name) ?? \"-\";\n        return {\n          ...p,\n          highlightedName: p.name,\n          highlightedLabel: label,\n        };\n      }),\n    };\n  }\n}\n\nclass PrefabNameMatcher implements PrefabMatcher {\n  regexp: RegExp;\n  labels: LabelHolder;\n\n  constructor(regexp: RegExp, labels: LabelHolder) {\n    this.regexp = regexp;\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const labels = await this.labels.prefabs;\n    const results = prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const highlightedName = matchAndHighlight(prefab.name, this.regexp);\n      const label = labels.get(prefab.name) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, this.regexp);\n      if (highlightedName ?? highlightedLabel) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label,\n        };\n      }\n      return [];\n    });\n    return {\n      status: `${results.length.toString()} matched prefabs`,\n      matched: results,\n    };\n  }\n}\n\nclass BlockNameMatcher implements PrefabMatcher {\n  regexp: RegExp;\n  blockPrefabIndex: BlockPrefabIndex;\n  labels: LabelHolder;\n\n  constructor(regexp: RegExp, blockPrefabIndex: BlockPrefabIndex, labels: LabelHolder) {\n    this.regexp = regexp;\n    this.blockPrefabIndex = blockPrefabIndex;\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const matchedBlocks = await this.matchBlocks();\n    if (matchedBlocks.length === 0) {\n      return { status: \"No matched blocks\", matched: [] };\n    }\n\n    const matchedPrefabBlocks = this.matchPrefabTypes(matchedBlocks);\n    if (Object.keys(matchedPrefabBlocks).length === 0) {\n      return { status: `No prefabs, but ${matchedBlocks.length.toString()} matched blocks`, matched: [] };\n    }\n\n    const labels = await this.labels.prefabs;\n    const results = prefabs.flatMap((prefab: Prefab) => {\n      const blocks = matchedPrefabBlocks[prefab.name];\n      if (!blocks) {\n        return [];\n      }\n      return {\n        ...prefab,\n        highlightedName: prefab.name,\n        highlightedLabel: labels.get(prefab.name) ?? \"-\",\n        matchedBlocks: blocks,\n      };\n    });\n    return {\n      status: `${results.length.toString()} prefabs, ${matchedBlocks.length.toString()} matched blocks`,\n      matched: results,\n    };\n  }\n\n  private async matchBlocks() {\n    const labels = await this.labels.blocks;\n    return Object.entries(this.blockPrefabIndex).reduce<HighlightedBlock[]>((arr, [blockName, prefabs]) => {\n      const highlightedName = matchAndHighlight(blockName, this.regexp);\n      const label = labels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, this.regexp);\n      if (highlightedName ?? highlightedLabel) {\n        return arr.concat({\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          prefabs,\n        });\n      }\n      return arr;\n    }, []);\n  }\n\n  private matchPrefabTypes(matchedBlocks: HighlightedBlock[]): PrefabHighlightedBlocks {\n    return matchedBlocks.reduce<PrefabHighlightedBlocks>((idx, block) => {\n      const { name, highlightedName, highlightedLabel } = block;\n      block.prefabs?.forEach((p) => {\n        const b = {\n          name,\n          highlightedName,\n          highlightedLabel,\n          count: p.count,\n        };\n        idx[p.name] = (idx[p.name] ?? []).concat(b);\n      });\n      return idx;\n    }, {});\n  }\n}\n", "import Prefabs from \"../lib/prefabs\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<Pick<Prefabs, \"all\" | \"prefabsFilterString\" | \"blocksFilterString\" | \"markCoords\" | \"language\">>;\n\nconst prefabs = new Prefabs(\"../labels\", navigator.languages);\n(async () => {\n  prefabs.blockPrefabIndex = await fetchJson(\"../block-prefab-index.json\");\n  prefabs.update();\n})().catch(printError);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update();\n};\n\nprefabs.addUpdateListener((u) => {\n  console.log(\"Prefab-filter send message: \", u);\n  postMessage(u);\n});\n"],
  "mappings": "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",
  "names": ["waitAnimationFrame", "printError", "e", "fetchJson", "url", "throttledInvoker", "asyncFunc", "workerPromises", "p", "prev", "waitAnimationFrame", "LANGUAGE_TAGS", "LabelHolder", "_LabelHolder", "#language", "#blocks", "#prefabs", "baseUrl", "navigatorLanguages", "resolveLanguage", "lang", "defaultLabels", "fileName", "Labels", "language", "fetchJson", "labels", "key", "languages", "clientTag", "tag", "path", "Prefabs", "#blockPrefabIndex", "#labelHolder", "throttledInvoker", "baseUrl", "navigatorLanguages", "LabelHolder", "lang", "filter", "s", "PrefabNameMatcher", "BlockNameMatcher", "index", "printError", "update", "f", "func", "AllMatcher", "result", "markCoords", "p", "calcDist", "distSorter", "nameSorter", "a", "b", "targetCoords", "baseCoords", "matchAndHighlight", "str", "regex", "isMatched", "highlighted", "m", "labels", "prefabs", "label", "regexp", "results", "prefab", "highlightedName", "highlightedLabel", "blockPrefabIndex", "matchedBlocks", "matchedPrefabBlocks", "blocks", "arr", "blockName", "idx", "block", "name", "prefabs", "Prefabs", "fetchJson", "printError", "data", "u"]
}
