{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/labels.ts", "../../src/lib/prefabs.ts", "../../src/worker/prefabs-filter.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(o: unknown, t: new (...a: unknown[]) => T, errorMessage = () => `Unexpected type: ${String(o)}`): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: GameMapSize,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords, mapSize: GameMapSize) => number | null,\n  event: EventOffsets | null,\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  const y = elevation(gameCoords, map) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function imageBitmapToPngBlob(img: ImageBitmap): Promise<PngBlob> {\n  const canvas = new OffscreenCanvas(img.height, img.width);\n  const context = requireNonnull(canvas.getContext(\"2d\"));\n  context.drawImage(img, 0, 0);\n  return (await canvas.convertToBlob({ type: \"image/png\" })) as PngBlob;\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  return (await (await fetch(url)).json()) as T;\n}\n\nexport async function invokeAll<T>(fns: ((t: T) => unknown)[], t: T): Promise<void> {\n  await Promise.all(fns.map((fn) => fn(t)));\n}\n", "import { waitAnimationFrame } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await waitAnimationFrame();\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "import { throttledInvoker } from \"./throttled-invoker\";\nimport { LabelHolder, Language } from \"./labels\";\nimport { printError } from \"./utils\";\n\nexport interface PrefabUpdate {\n  status: string;\n  prefabs: HighlightedPrefab[];\n}\n\ninterface PrefabHighlightedBlocks {\n  [prefabName: string]: HighlightedBlock[];\n}\n\nexport default class Prefabs {\n  all: Prefab[] = [];\n  filtered: HighlightedPrefab[] = [];\n  markCoords: GameCoords | null = null;\n  status = \"\";\n\n  #blockPrefabCounts: BlockPrefabCounts = {};\n  #labelHolder: LabelHolder;\n  filter: PrefabMatcher;\n\n  private throttledUpdater = throttledInvoker(() => this.updateImmediately());\n  private updateListeners: ((u: PrefabUpdate) => void)[] = [];\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#labelHolder = new LabelHolder(baseUrl, navigatorLanguages);\n    this.filter = this.defaultMatcher();\n  }\n\n  set language(lang: Language) {\n    this.#labelHolder.language = lang;\n  }\n\n  /**\n   * Filter by prefab names.\n   *\n   * filter string is used as a regular expression or some special strings:\n   *\n   * - `\uD83D\uDC801`, `\uD83D\uDC802`, ... , `\uD83D\uDC805`: filter by it's difficulty tiers\n   *\n   * @param filter - A string to filter prefabs.\n   */\n  set prefabsFilterString(filter: string) {\n    const s = filter.trim();\n    if (s.length === 0) {\n      this.filter = this.defaultMatcher();\n    } else if (/^\uD83D\uDC80\\d+$/.test(s)) {\n      this.filter = new DifficultyMatcher(parseInt(s.slice(2), 10), this.#labelHolder);\n    } else {\n      this.filter = new PrefabNameMatcher(new RegExp(s, \"i\"), this.#labelHolder);\n    }\n  }\n  set blocksFilterString(filter: string) {\n    const s = filter.trim();\n    if (s.length === 0) {\n      this.filter = this.defaultMatcher();\n    } else {\n      this.filter = new BlockNameMatcher(new RegExp(s, \"i\"), this.#blockPrefabCounts, this.#labelHolder);\n    }\n  }\n\n  set blockPrefabCounts(counts: BlockPrefabCounts) {\n    this.#blockPrefabCounts = counts;\n    if (this.filter instanceof BlockNameMatcher) {\n      this.filter = new BlockNameMatcher(this.filter.regexp, counts, this.#labelHolder);\n    }\n  }\n\n  update(): void {\n    this.throttledUpdater().catch(printError);\n  }\n  async updateImmediately(): Promise<void> {\n    await this.applyFilter();\n    this.updateDist();\n    this.sort();\n    const update: PrefabUpdate = { status: this.status, prefabs: this.filtered };\n    this.updateListeners.forEach((f) => {\n      f(update);\n    });\n  }\n\n  addUpdateListener(func: (update: PrefabUpdate) => void): void {\n    this.updateListeners.push(func);\n  }\n\n  private defaultMatcher() {\n    return new AllMatcher(this.#labelHolder);\n  }\n\n  private async applyFilter() {\n    const result = await this.filter.match(this.all);\n    this.status = result.status;\n    this.filtered = result.matched;\n  }\n\n  private updateDist() {\n    if (this.markCoords) {\n      const { markCoords } = this;\n      this.filtered.forEach((p) => (p.dist = calcDist(p, markCoords)));\n    } else {\n      this.filtered.forEach((p) => (p.dist = null));\n    }\n  }\n\n  private sort() {\n    if (this.markCoords) {\n      this.status = `${this.status}, order by distances from the flag`;\n      this.filtered.sort(distSorter);\n    } else if (this.filter instanceof BlockNameMatcher) {\n      this.status = `${this.status}, order by counts of matched blocks`;\n      this.filtered.sort(blockCountSorter);\n    } else {\n      this.filtered.sort(nameSorter);\n    }\n  }\n}\n\nfunction nameSorter(a: { name: string }, b: { name: string }) {\n  if (a.name > b.name) return 1;\n  if (a.name < b.name) return -1;\n  return 0;\n}\n\nfunction blockCountSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.matchedBlocks || !b.matchedBlocks) return nameSorter(a, b);\n  const aCount = a.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  const bCount = b.matchedBlocks.reduce((acc, b) => acc + (b.count ?? 0), 0);\n  if (aCount < bCount) return 1;\n  if (aCount > bCount) return -1;\n  return nameSorter(a, b);\n}\n\nfunction distSorter(a: HighlightedPrefab, b: HighlightedPrefab) {\n  if (!a.dist || !b.dist) return nameSorter(a, b);\n  if (a.dist > b.dist) return 1;\n  if (a.dist < b.dist) return -1;\n  return nameSorter(a, b);\n}\n\nfunction calcDist(targetCoords: GameCoords, baseCoords: GameCoords) {\n  return Math.round(Math.sqrt((targetCoords.x - baseCoords.x) ** 2 + (targetCoords.z - baseCoords.z) ** 2));\n}\n\nfunction matchAndHighlight(str: string, regex: RegExp) {\n  let isMatched = false;\n  const highlighted = str.replace(regex, (m) => {\n    isMatched = m.length > 0;\n    return `<mark>${m}</mark>`;\n  });\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return isMatched ? highlighted : null;\n}\n\ninterface PrefabMatcher {\n  match(prefabs: Prefab[]): Promise<PrefabMatcherResult>;\n}\ninterface PrefabMatcherResult {\n  status: string;\n  matched: HighlightedPrefab[];\n}\n\nclass AllMatcher implements PrefabMatcher {\n  labels: LabelHolder;\n\n  constructor(labels: LabelHolder) {\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const labels = await this.labels.get(\"prefabs\");\n    return {\n      status: prefabs.length === 0 ? \"No prefabs\" : \"All prefabs\",\n      matched: prefabs.map((p) => {\n        const label = labels.get(p.name) ?? \"-\";\n        return {\n          ...p,\n          highlightedName: p.name,\n          highlightedLabel: label,\n        };\n      }),\n    };\n  }\n}\n\nclass PrefabNameMatcher implements PrefabMatcher {\n  regexp: RegExp;\n  labels: LabelHolder;\n\n  constructor(regexp: RegExp, labels: LabelHolder) {\n    this.regexp = regexp;\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const labels = await this.labels.get(\"prefabs\");\n    const results = prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      const highlightedName = matchAndHighlight(prefab.name, this.regexp);\n      const label = labels.get(prefab.name) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, this.regexp);\n      if (highlightedName ?? highlightedLabel) {\n        return {\n          ...prefab,\n          highlightedName: highlightedName ?? prefab.name,\n          highlightedLabel: highlightedLabel ?? label,\n        };\n      }\n      return [];\n    });\n    return {\n      status: `${results.length.toString()} matched prefabs`,\n      matched: results,\n    };\n  }\n}\n\nclass BlockNameMatcher implements PrefabMatcher {\n  regexp: RegExp;\n  #blockPrefabCounts: BlockPrefabCounts;\n  labels: LabelHolder;\n\n  constructor(regexp: RegExp, counts: BlockPrefabCounts, labels: LabelHolder) {\n    this.regexp = regexp;\n    this.#blockPrefabCounts = counts;\n    this.labels = labels;\n  }\n\n  async match(prefabs: Prefab[]) {\n    const matchedBlocks = await this.matchBlocks();\n    if (matchedBlocks.length === 0) {\n      return { status: \"No matched blocks\", matched: [] };\n    }\n\n    const matchedPrefabBlocks = this.matchPrefabTypes(matchedBlocks);\n    if (Object.keys(matchedPrefabBlocks).length === 0) {\n      return { status: `No prefabs, but ${matchedBlocks.length.toString()} matched blocks`, matched: [] };\n    }\n\n    const labels = await this.labels.get(\"prefabs\");\n    const results = prefabs.flatMap((prefab: Prefab) => {\n      const blocks = matchedPrefabBlocks[prefab.name];\n      if (!blocks) {\n        return [];\n      }\n      return {\n        ...prefab,\n        highlightedName: prefab.name,\n        highlightedLabel: labels.get(prefab.name) ?? \"-\",\n        matchedBlocks: blocks,\n      };\n    });\n    return {\n      status: `${results.length.toString()} prefabs, ${matchedBlocks.length.toString()} matched blocks`,\n      matched: results,\n    };\n  }\n\n  private async matchBlocks() {\n    const blockLabels = await this.labels.get(\"blocks\");\n    const shapeLabels = await this.labels.get(\"shapes\");\n    return Object.entries(this.#blockPrefabCounts).flatMap<HighlightedBlock>(([blockName, prefabs]) => {\n      const highlightedName = matchAndHighlight(blockName, this.regexp);\n      const label = blockLabels.get(blockName) ?? shapeLabels.get(blockName) ?? \"-\";\n      const highlightedLabel = label && matchAndHighlight(label, this.regexp);\n      if (highlightedName ?? highlightedLabel) {\n        return {\n          name: blockName,\n          highlightedName: highlightedName ?? blockName,\n          highlightedLabel: highlightedLabel ?? label,\n          prefabs,\n        };\n      }\n      return [];\n    });\n  }\n\n  private matchPrefabTypes(matchedBlocks: HighlightedBlock[]): PrefabHighlightedBlocks {\n    return matchedBlocks.reduce<PrefabHighlightedBlocks>((acc, block) => {\n      if (!block.prefabs) return acc;\n      for (const [prefabName, count] of Object.entries(block.prefabs)) {\n        acc[prefabName] = (acc[prefabName] ?? []).concat({ ...block, count });\n      }\n      return acc;\n    }, {});\n  }\n}\n\nclass DifficultyMatcher implements PrefabMatcher {\n  constructor(\n    private difficulty: number,\n    private labels: LabelHolder,\n  ) {\n    this.difficulty = difficulty;\n  }\n\n  async match(prefabs: Prefab[]) {\n    if (isNaN(this.difficulty) || this.difficulty < 1 || this.difficulty > 5) {\n      return Promise.resolve({ status: `Invalid difficulty tier: ${this.difficulty.toString()}`, matched: [] });\n    }\n    const labels = await this.labels.get(\"prefabs\");\n    const matched = prefabs.flatMap<HighlightedPrefab>((prefab) => {\n      if (prefab.difficulty !== this.difficulty) return [];\n      const label = labels.get(prefab.name) ?? \"-\";\n      return {\n        ...prefab,\n        highlightedName: prefab.name,\n        highlightedLabel: label,\n      };\n    });\n    return {\n      status: `${matched.length.toString()} prefabs with difficulty tier ${this.difficulty.toString()}`,\n      matched,\n    };\n  }\n}\n", "import Prefabs from \"../lib/prefabs\";\nimport { printError, fetchJson } from \"../lib/utils\";\n\nexport type InMessage = Partial<Pick<Prefabs, \"all\" | \"prefabsFilterString\" | \"blocksFilterString\" | \"markCoords\" | \"language\">>;\n\nconst prefabs = new Prefabs(\"../labels\", navigator.languages);\n(async () => {\n  prefabs.blockPrefabCounts = invertCounts(await fetchJson(\"../prefab-block-counts.json\"));\n  prefabs.update();\n})().catch(printError);\n\nonmessage = ({ data }: MessageEvent<InMessage>) => {\n  console.log(\"Prefab-filter received message: \", data);\n  Object.assign(prefabs, data).update();\n};\n\nprefabs.addUpdateListener((u) => {\n  console.log(\"Prefab-filter send message: \", u);\n  postMessage(u);\n});\n\nfunction invertCounts(counts: PrefabBlockCounts): BlockPrefabCounts {\n  const blockPrefabCounts: BlockPrefabCounts = {};\n  for (const [prefabName, blockCounts] of Object.entries(counts))\n    for (const [blockName, count] of Object.entries(blockCounts))\n      blockPrefabCounts[blockName] = Object.assign(blockPrefabCounts[blockName] ?? {}, { [prefabName]: count });\n  return blockPrefabCounts;\n}\n"],
  "mappings": "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",
  "names": ["waitAnimationFrame", "printError", "e", "fetchJson", "url", "throttledInvoker", "asyncFunc", "workerPromises", "p", "prev", "waitAnimationFrame", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "Prefabs", "#blockPrefabCounts", "#labelHolder", "throttledInvoker", "baseUrl", "navigatorLanguages", "LabelHolder", "lang", "filter", "s", "DifficultyMatcher", "PrefabNameMatcher", "BlockNameMatcher", "counts", "printError", "update", "f", "func", "AllMatcher", "result", "markCoords", "p", "calcDist", "distSorter", "blockCountSorter", "nameSorter", "a", "b", "aCount", "acc", "bCount", "targetCoords", "baseCoords", "matchAndHighlight", "str", "regex", "isMatched", "highlighted", "m", "labels", "prefabs", "label", "regexp", "results", "prefab", "highlightedName", "highlightedLabel", "matchedBlocks", "matchedPrefabBlocks", "blocks", "blockLabels", "shapeLabels", "blockName", "block", "prefabName", "count", "difficulty", "matched", "prefabs", "Prefabs", "invertCounts", "fetchJson", "printError", "data", "u", "counts", "blockPrefabCounts", "prefabName", "blockCounts", "blockName", "count"]
}
