{
  "version": 3,
  "sources": ["../../lib/map-files.ts", "../../src/lib/storage.ts", "../../src/lib/utils.ts", "../../src/worker/dtm.ts"],
  "sourcesContent": ["import type * as pngjs from \"pngjs\";\n\n/**\n * pngjs needs to be set depending on the environment.\n *\n * Set \"pngjs\" module if in the Node.js.\n * Set \"pngjs/browser\" module if in the browser.\n */\nlet PNG: typeof pngjs.PNG;\nexport function setPNG(png: typeof pngjs.PNG): void {\n  PNG = png;\n}\n\n/**\n * the `name` is the file name to be stored.\n * the `process` is the function to process the file.\n *\n * the name is optional, if not provided, the original file name will be used.\n */\nconst FILE_PROCESS_RULES = {\n  \"map_info.xml\": {\n    name: \"map_info.xml\",\n    process: copy,\n  },\n  \"biomes.png\": {\n    name: \"biomes.png\",\n    process: repackPng,\n  },\n  \"splat3.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat3_processed.png\": {\n    name: \"splat3.png\",\n    process: processSplat3Png,\n  },\n  \"splat4.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"splat4_processed.png\": {\n    name: \"splat4.png\",\n    process: processSplat4Png,\n  },\n  \"radiation.png\": {\n    name: \"radiation.png\",\n    process: processRadiationPng,\n  },\n  \"prefabs.xml\": {\n    name: \"prefabs.xml\",\n    process: copy,\n  },\n  \"dtm.raw\": {\n    name: \"dtm_block.raw.gz\",\n    process: (i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>) => i.pipeThrough(new DtmRawTransformer()).pipeTo(o),\n  },\n} as const;\n\nexport type WorldFileName = keyof typeof FILE_PROCESS_RULES;\nexport type MapFileNameMap<T extends keyof typeof FILE_PROCESS_RULES> = (typeof FILE_PROCESS_RULES)[T][\"name\"];\nexport const MAP_FILE_NAME_MAP = Object.fromEntries(Object.entries(FILE_PROCESS_RULES).map(([k, v]) => [k, v.name])) as {\n  [K in WorldFileName]: MapFileNameMap<K>;\n};\nexport type MapFileName = MapFileNameMap<WorldFileName>;\n\nexport class Processor<T extends keyof typeof FILE_PROCESS_RULES> {\n  #worldFileName: T;\n\n  constructor(worldFileName: T) {\n    this.#worldFileName = worldFileName;\n  }\n\n  get mapFileName(): MapFileNameMap<T> {\n    return FILE_PROCESS_RULES[this.#worldFileName].name;\n  }\n\n  async process(src: ReadableStream<Uint8Array>, dst: WritableStream<Uint8Array>): Promise<void> {\n    await FILE_PROCESS_RULES[this.#worldFileName].process(src, dst);\n  }\n}\n\nexport const WORLD_FILE_NAMES = new Set(Object.keys(FILE_PROCESS_RULES)) as Set<keyof typeof FILE_PROCESS_RULES>;\n\nexport function isWorldFileName(name: string): name is keyof typeof FILE_PROCESS_RULES {\n  return WORLD_FILE_NAMES.has(name as keyof typeof FILE_PROCESS_RULES);\n}\n\nexport const MAP_FILE_NAMES = new Set(Object.values(FILE_PROCESS_RULES).map((v) => v.name));\n\nexport function isMapFileName(name: string): name is MapFileNameMap<WorldFileName> {\n  return MAP_FILE_NAMES.has(name as unknown as (typeof FILE_PROCESS_RULES)[keyof typeof FILE_PROCESS_RULES][\"name\"]);\n}\n\nexport function getMapFileName(name: WorldFileName): MapFileNameMap<WorldFileName> {\n  return FILE_PROCESS_RULES[name].name;\n}\n\n/**\n * The value file name is preferred to be used instead of the key file name.\n */\nexport const PREFER_WORLD_FILE_NAMES = {\n  \"splat3.png\": \"splat3_processed.png\",\n  \"splat4.png\": \"splat4_processed.png\",\n} as const;\n\n/**\n * Filter the file names which are not in the `FILE_PROCESS_RULES`.\n * And filter the file names which are preferred to be used.\n * @param names The file names to be filtered\n * @returns The filtered file names\n */\nexport function filterWorldFileNames(names: string[]): WorldFileName[] {\n  const n = names.filter(isWorldFileName);\n  return n.filter((f) => !n.includes(PREFER_WORLD_FILE_NAMES[f as keyof typeof PREFER_WORLD_FILE_NAMES]));\n}\n\n/**\n * @param name The file name\n * @param files The file names\n * @returns true if the file `name` has the preferred file name in the `files`\n */\nexport function hasPreferWorldFileNameIn(name: string, files: string[]): boolean {\n  return name in PREFER_WORLD_FILE_NAMES && files.includes(PREFER_WORLD_FILE_NAMES[name as keyof typeof PREFER_WORLD_FILE_NAMES]);\n}\n\nexport function getPreferWorldFileName(name: string): string | undefined {\n  return (PREFER_WORLD_FILE_NAMES as Record<string, string>)[name];\n}\n\nfunction copy(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeTo(o);\n}\n\nfunction repackPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RepackPngTransformer()).pipeTo(o);\n}\n\nfunction processSplat3Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat3PngTransformer()).pipeTo(o);\n}\n\nfunction processSplat4Png(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new Splat4PngTransformer()).pipeTo(o);\n}\n\nfunction processRadiationPng(i: ReadableStream<Uint8Array>, o: WritableStream<Uint8Array>): Promise<void> {\n  return i.pipeThrough(new RadiationPngTransformer()).pipeTo(o);\n}\n\nconst DEFAULT_TRASNFORM_STRATEGY = { highWaterMark: 1024 * 1024 };\nconst DEFAULT_TRASNFORM_STRATEGIES = [DEFAULT_TRASNFORM_STRATEGY, DEFAULT_TRASNFORM_STRATEGY] as const;\n\nclass ComposingTransformer {\n  readable: ReadableStream<Uint8Array>;\n  writable: WritableStream<Uint8Array>;\n  constructor(transformStreams: TransformStream<Uint8Array, Uint8Array>[]) {\n    const { readable, writable } = new TransformStream<Uint8Array, Uint8Array>({}, ...DEFAULT_TRASNFORM_STRATEGIES);\n    this.readable = transformStreams.reduce((r, t) => r.pipeThrough(t), readable);\n    this.writable = writable;\n  }\n}\n\n/**\n * Pick odd bytes which indicate block height\n * raw[i] Sub-Block Height\n * raw[i + 1] Block Height\n */\nclass OddByteTransformer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    let nextOffset = 1;\n    super(\n      {\n        transform(chunk, controller) {\n          const buffer = new Uint8Array(\n            chunk.length % 2 === 0 ? chunk.length / 2 : nextOffset === 1 ? (chunk.length - 1) / 2 : (chunk.length + 1) / 2,\n          );\n\n          let i = nextOffset;\n          for (; i < chunk.length; i += 2) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer[(i - nextOffset) / 2] = chunk[i]!;\n          }\n\n          nextOffset = i - chunk.length;\n          controller.enqueue(buffer);\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nclass DtmRawTransformer extends ComposingTransformer {\n  constructor() {\n    super([new OddByteTransformer(), new CompressionStream(\"gzip\")]);\n  }\n}\n\nexport class DtmBlockRawDecompressor extends DecompressionStream implements TransformStream<Uint8Array, Uint8Array> {\n  constructor() {\n    super(\"gzip\");\n  }\n}\n\nclass PngEditingTransfomer extends TransformStream<Uint8Array, Uint8Array> {\n  constructor(copyAndEdit: (src: Uint8Array, dst: Uint8ClampedArray | Uint8Array) => void) {\n    const png = new PNG({ deflateLevel: 9, deflateStrategy: 0 });\n    const { promise: flushPromise, resolve, reject }: PromiseWithResolvers<void> = Promise.withResolvers();\n    super(\n      {\n        start(controller) {\n          png.on(\"parsed\", () => {\n            packPng(png, copyAndEdit, controller)\n              .then(resolve)\n              .catch((e: unknown) => {\n                reject(e);\n              });\n          });\n        },\n        transform(chunk) {\n          png.write(chunk);\n        },\n        flush() {\n          return flushPromise;\n        },\n      },\n      ...DEFAULT_TRASNFORM_STRATEGIES,\n    );\n  }\n}\n\nasync function packPng(\n  png: pngjs.PNG,\n  copyAndEdit: (src: Uint8Array, dst: Uint8Array | Uint8ClampedArray) => void,\n  controller: TransformStreamDefaultController<Uint8Array>,\n): Promise<void> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (globalThis.OffscreenCanvas) {\n    // Faster png packing using OffscreenCanvas\n    const canvas = new OffscreenCanvas(png.width, png.height);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const ctx = canvas.getContext(\"2d\")!;\n    const imageData = ctx.createImageData(png.width, png.height);\n    copyAndEdit(png.data, imageData.data);\n    ctx.putImageData(imageData, 0, 0);\n    const blob = await canvas.convertToBlob({ type: \"image/png\" });\n    for await (const chunk of blob.stream()) controller.enqueue(chunk);\n  } else {\n    copyAndEdit(png.data, png.data);\n    return new Promise((resolve, reject) => {\n      png\n        .pack()\n        .on(\"data\", (chunk: Uint8Array) => {\n          controller.enqueue(chunk);\n        })\n        .on(\"error\", reject)\n        .on(\"end\", resolve);\n    });\n  }\n}\n\n/**\n * splat3.png should convert the pixels which:\n *   - black to transparent\n *   - other to non-transparent\n */\nclass Splat3PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < dst.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * splat4.png/splat4_processed.png should convert the pixels which:\n *   - Black to 100% transparent\n *   - Non-black to non-transparent\n *   - Green to blue because they are water\n *   - rgb(0, 0, 29) to blue for splat4.png not splat4_processed.png\n *     See https://github.com/kui/7dtd-map/issues/103\n */\nclass Splat4PngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else if (src[i + 1] === 255 || src[i + 2] === 29) {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 2]!;\n          dst[i + 2] = 255;\n          dst[i + 3] = 255;\n        } else {\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          dst[i + 3] = 255;\n          /* eslint-enable */\n        }\n      }\n    });\n  }\n}\n\n/**\n * radiation.png should convert the pixels which:\n *   - black to 100% transparent\n *   - other to non-transparent\n */\nclass RadiationPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i += 4) {\n        if (src[i] === 0 && src[i + 1] === 0 && src[i + 2] === 0) {\n          dst[i] = 0;\n          dst[i + 1] = 0;\n          dst[i + 2] = 0;\n          dst[i + 3] = 0;\n        } else {\n          /* eslint-disable @typescript-eslint/no-non-null-assertion */\n          dst[i] = src[i]!;\n          dst[i + 1] = src[i + 1]!;\n          dst[i + 2] = src[i + 2]!;\n          /* eslint-enable */\n          dst[i + 3] = 255;\n        }\n      }\n    });\n  }\n}\n\n/**\n * Just to repack the PNG\n */\nclass RepackPngTransformer extends PngEditingTransfomer {\n  constructor() {\n    super((src, dst) => {\n      for (let i = 0; i < src.length; i++) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        dst[i] = src[i]!;\n      }\n    });\n  }\n}\n", "import { MapFileName } from \"../../lib/map-files\";\n\nconst MAPS_DIR = \"maps\";\nconst WORKSPACE_DIR = \"workspace\";\n\nexport async function* listMapDirs(): AsyncIterable<MapDir> {\n  const worlds = await mapsDir();\n  for await (const entry of worlds.values()) {\n    if (entry.kind === \"directory\") {\n      yield new MapDir(entry as FileSystemDirectoryHandle);\n    }\n  }\n}\n\nexport async function mapDir(name: string): Promise<MapDir> {\n  const worlds = await mapsDir();\n  return new MapDir(await worlds.getDirectoryHandle(name, { create: true }));\n}\n\nexport async function workspaceDir(): Promise<MapDir> {\n  const root = await navigator.storage.getDirectory();\n  return new MapDir(await root.getDirectoryHandle(WORKSPACE_DIR, { create: true }));\n}\n\nasync function mapsDir() {\n  const root = await navigator.storage.getDirectory();\n  return root.getDirectoryHandle(MAPS_DIR, { create: true });\n}\n\nexport class MapDir {\n  #dir: FileSystemDirectoryHandle;\n\n  constructor(dir: FileSystemDirectoryHandle) {\n    this.#dir = dir;\n  }\n\n  get name(): string {\n    return this.#dir.name;\n  }\n\n  async put(name: MapFileName, data: ArrayBuffer | Blob | ReadableStream<Uint8Array>) {\n    console.debug(\"put\", name);\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    const writable = await file.createWritable();\n    if (data instanceof ArrayBuffer || data instanceof Blob) {\n      await writable.write(data);\n    } else {\n      await data.pipeTo(writable);\n    }\n    await writable.close();\n  }\n\n  async createWritable(name: MapFileName): Promise<FileSystemWritableFileStream> {\n    const file = await this.#dir.getFileHandle(name, { create: true });\n    return await file.createWritable();\n  }\n\n  async get(name: MapFileName): Promise<File | null> {\n    console.debug(\"get\", name);\n    try {\n      const file = await this.#dir.getFileHandle(name);\n      return await file.getFile();\n    } catch (e: unknown) {\n      if (e instanceof DOMException && e.name === \"NotFoundError\") {\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  async size(name: MapFileName): Promise<number> {\n    const file = await this.#dir.getFileHandle(name);\n    return (await file.getFile()).size;\n  }\n\n  async remove(name: MapFileName) {\n    await this.#dir.removeEntry(name);\n  }\n}\n", "export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(\n  o: unknown,\n  t: new (...a: unknown[]) => T,\n  errorMessage = () => `Unexpected type: expected as ${String(t)}, but actual type ${String(o)}`,\n): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport async function formatCoords(\n  map: GameMapSize | null,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords) => Promise<number | null>,\n  event: EventOffsets | null,\n): Promise<string> {\n  if (!event || !map) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) return \"E/W: -, N/S: -, Elev: -\";\n\n  const y = (await elevation(gameCoords)) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  const r = await fetch(url);\n  if (!r.ok) throw Error(`Failed to fetch ${url}: ${r.statusText}`);\n  return (await r.json()) as T;\n}\n\nexport function basename(path: string) {\n  return path.substring(path.lastIndexOf(\"/\") + 1);\n}\n\nexport async function readWholeStream(stream: ReadableStream<Uint8Array>): Promise<Uint8Array> {\n  return new Uint8Array(await new Response(stream).arrayBuffer());\n}\n", "import { DtmBlockRawDecompressor } from \"../../lib/map-files\";\nimport * as storage from \"../lib/storage\";\nimport { printError, readWholeStream } from \"../lib/utils\";\n\nexport type OutMessage = null | Uint8Array;\n\nasync function main() {\n  const workspace = await storage.workspaceDir();\n  let msg: OutMessage = null;\n  try {\n    msg = await readDtmBlockRaw(workspace);\n  } catch (e) {\n    console.error(e);\n  }\n  postMessage(msg, msg ? [msg.buffer] : []);\n  close();\n}\n\nasync function readDtmBlockRaw(workspace: storage.MapDir): Promise<Uint8Array | null> {\n  const file = await workspace.get(\"dtm_block.raw.gz\");\n  if (!file) return null;\n  return readWholeStream(file.stream().pipeThrough(new DtmBlockRawDecompressor() as TransformStream<Uint8Array, Uint8Array>));\n}\n\nmain().catch(printError);\n"],
  "mappings": "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",
  "names": []
}
