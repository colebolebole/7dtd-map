{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/image-bitmap-holder.ts", "../../src/lib/throttled-invoker.ts", "../../src/lib/map-renderer.ts", "../../src/worker/map-renderer.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t != null) return t;\n  else throw Error(errorMessage());\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(o: unknown, t: new (...a: unknown[]) => T, errorMessage = () => `Unexpected type: ${String(o)}`): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: GameMapSize,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords, mapSize: GameMapSize) => number | null,\n  event: EventOffsets | null,\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  const y = elevation(gameCoords, map) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nexport async function imageBitmapToPngBlob(img: ImageBitmap): Promise<PngBlob> {\n  const canvas = new OffscreenCanvas(img.height, img.width);\n  const context = requireNonnull(canvas.getContext(\"2d\"));\n  context.drawImage(img, 0, 0);\n  return (await canvas.convertToBlob({ type: \"image/png\" })) as PngBlob;\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  return (await (await fetch(url)).json()) as T;\n}\n\nexport async function invokeAll<T>(fns: ((t: T) => unknown)[], t: T): Promise<void> {\n  await Promise.all(fns.map((fn) => fn(t)));\n}\n", "import { imageBitmapToPngBlob, requireNonnull } from \"./utils\";\n\nconst IMG_AGE_MSEC = 10000;\n\nexport class ImageBitmapHolder {\n  private label;\n  _png: PngBlob | Promise<PngBlob>;\n  private img?: ImageBitmap | null;\n  private fallbackPromise: Promise<ImageBitmap> | null = null;\n  private lastAccessAt = 0;\n  private imgAge;\n\n  constructor(label: string, original: PngBlob | ImageBitmap, imgAge = IMG_AGE_MSEC) {\n    this.label = label;\n    if (isPngBlob(original)) {\n      this._png = original;\n    } else {\n      this._png = imageBitmapToPngBlob(original);\n      this.setImg(original);\n    }\n    this.imgAge = imgAge;\n  }\n\n  async get(): Promise<ImageBitmap> {\n    this.lastAccessAt = Date.now();\n    return this.img ?? this.fallbackPromise ?? this.getFallback();\n  }\n\n  private async getFallback() {\n    this.fallbackPromise = this.getImageBitmap();\n    return this.fallbackPromise;\n  }\n\n  private async getImageBitmap() {\n    console.debug(\"Fallback\", this.label);\n    const img = await createImageBitmap(await this._png);\n    this.setImg(img);\n    this.fallbackPromise = null;\n    return img;\n  }\n\n  private setImg(img: ImageBitmap) {\n    this.img = img;\n    setTimeout(() => {\n      this.expireImage();\n    }, this.imgAge);\n  }\n\n  private expireImage() {\n    if (Date.now() - this.lastAccessAt > this.imgAge) {\n      console.debug(\"Expire\", this.label);\n      requireNonnull(this.img).close();\n      this.img = null;\n    } else {\n      setTimeout(() => {\n        this.expireImage();\n      }, this.imgAge);\n    }\n  }\n}\n\nfunction isPngBlob(o: PngBlob | ImageBitmap): o is PngBlob {\n  return o instanceof Blob;\n}\n", "import { waitAnimationFrame } from \"./utils\";\n\nexport function throttledInvoker(asyncFunc: () => Promise<void> | void): () => Promise<void> {\n  const workerPromises: Promise<void>[] = [];\n  return () => {\n    switch (workerPromises.length) {\n      case 0: {\n        const p = (async () => {\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 1: {\n        const prev = workerPromises[0];\n        const p = (async () => {\n          await prev;\n          await waitAnimationFrame();\n          await asyncFunc();\n          void workerPromises.shift();\n        })();\n        workerPromises.push(p);\n        return p;\n      }\n      case 2:\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return workerPromises[1]!;\n      default:\n        throw Error(`Unexpected state: promiceses=${workerPromises.length.toString()}`);\n    }\n  };\n}\n", "import { ImageBitmapHolder } from \"./image-bitmap-holder\";\nimport { throttledInvoker } from \"./throttled-invoker\";\nimport { gameMapSize } from \"./utils\";\n\nconst SIGN_CHAR = \"\u2718\";\nconst MARK_CHAR = \"\uD83D\uDEA9\uFE0F\";\n\nexport default class MapRenderer {\n  brightness = \"100%\";\n  markerCoords: GameCoords | null = null;\n  scale = 0.1;\n  showPrefabs = true;\n  prefabs: HighlightedPrefab[] = [];\n  signSize = 200;\n  signAlpha = 1;\n  biomesAlpha = 1;\n  splat3Alpha = 1;\n  splat4Alpha = 1;\n  radAlpha = 1;\n\n  canvas: OffscreenCanvas;\n\n  update = throttledInvoker(async () => {\n    console.time(\"MapUpdate\");\n    await this.updateImmediately();\n    console.timeEnd(\"MapUpdate\");\n  });\n\n  private _biomesImg: ImageBitmapHolder | null = null;\n  private _splat3Img: ImageBitmapHolder | null = null;\n  private _splat4Img: ImageBitmapHolder | null = null;\n  private _radImg: ImageBitmapHolder | null = null;\n  private fontFace: FontFace;\n\n  constructor(canvas: OffscreenCanvas, fontFace: FontFace) {\n    this.canvas = canvas;\n    this.fontFace = fontFace;\n  }\n\n  set biomesImg(img: ImageBitmap | PngBlob | null) {\n    this._biomesImg = img ? new ImageBitmapHolder(\"biomes\", img) : null;\n  }\n  set splat3Img(img: ImageBitmap | PngBlob | null) {\n    this._splat3Img = img ? new ImageBitmapHolder(\"splat3\", img) : null;\n  }\n  set splat4Img(img: ImageBitmap | PngBlob | null) {\n    this._splat4Img = img ? new ImageBitmapHolder(\"splat4\", img) : null;\n  }\n  set radImg(img: ImageBitmap | PngBlob | null) {\n    this._radImg = img ? new ImageBitmapHolder(\"rad\", img) : null;\n  }\n\n  async size(): Promise<GameMapSize> {\n    const rects = await Promise.all([this._biomesImg?.get(), this._splat3Img?.get(), this._splat4Img?.get()]);\n    return gameMapSize({\n      width: Math.max(...rects.map((r) => r?.width ?? 0)),\n      height: Math.max(...rects.map((r) => r?.height ?? 0)),\n    });\n  }\n\n  private isBlank(): boolean {\n    return !this._biomesImg && !this._splat3Img && !this._splat4Img;\n  }\n\n  async updateImmediately(): Promise<void> {\n    if (this.isBlank()) {\n      this.canvas.width = 1;\n      this.canvas.height = 1;\n      return;\n    }\n\n    const { width, height } = await this.size();\n\n    this.canvas.width = width * this.scale;\n    this.canvas.height = height * this.scale;\n\n    const context = this.canvas.getContext(\"2d\");\n    if (!context) return;\n    context.scale(this.scale, this.scale);\n    context.filter = `brightness(${this.brightness})`;\n\n    if (this._biomesImg && this.biomesAlpha !== 0) {\n      context.globalAlpha = this.biomesAlpha;\n      context.drawImage(await this._biomesImg.get(), 0, 0, width, height);\n    }\n    if (this._splat3Img && this.splat3Alpha !== 0) {\n      context.globalAlpha = this.splat3Alpha;\n      context.drawImage(await this._splat3Img.get(), 0, 0, width, height);\n    }\n    if (this._splat4Img && this.splat4Alpha !== 0) {\n      context.globalAlpha = this.splat4Alpha;\n      context.drawImage(await this._splat4Img.get(), 0, 0, width, height);\n    }\n\n    context.filter = \"none\";\n    if (this._radImg && this.radAlpha !== 0) {\n      context.globalAlpha = this.radAlpha;\n      context.imageSmoothingEnabled = false;\n      context.drawImage(await this._radImg.get(), 0, 0, width, height);\n      context.imageSmoothingEnabled = true;\n    }\n\n    context.globalAlpha = this.signAlpha;\n    if (this.showPrefabs) {\n      this.drawPrefabs(context, width, height);\n    }\n    if (this.markerCoords) {\n      this.drawMark(context, width, height);\n    }\n  }\n\n  private drawPrefabs(ctx: OffscreenCanvasRenderingContext2D, width: number, height: number) {\n    ctx.font = `${this.signSize.toString()}px ${this.fontFace.family}`;\n    ctx.fillStyle = \"red\";\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n\n    const offsetX = width / 2;\n    const offsetY = height / 2;\n\n    const charOffsetX = Math.round(this.signSize * 0.01);\n    const charOffsetY = Math.round(this.signSize * 0.05);\n\n    // Inverted iteration to overwrite signs by higher order prefabs\n    for (const prefab of this.prefabs.toReversed()) {\n      const x = offsetX + prefab.x + charOffsetX;\n      // prefab vertical positions are inverted for canvas coodinates\n      const z = offsetY - prefab.z + charOffsetY;\n      putText(ctx, { text: SIGN_CHAR, x, z, size: this.signSize });\n    }\n  }\n\n  private drawMark(ctx: OffscreenCanvasRenderingContext2D, width: number, height: number) {\n    if (!this.markerCoords) return;\n\n    ctx.font = `${this.signSize.toString()}px ${this.fontFace.family}`;\n    ctx.fillStyle = \"red\";\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"alphabetic\";\n\n    const offsetX = width / 2;\n    const offsetY = height / 2;\n    const charOffsetX = -1 * Math.round(this.signSize * 0.32);\n    const charOffsetY = -1 * Math.round(this.signSize * 0.1);\n\n    const x = offsetX + this.markerCoords.x + charOffsetX;\n    const z = offsetY - this.markerCoords.z + charOffsetY;\n\n    putText(ctx, { text: MARK_CHAR, x, z, size: this.signSize });\n    ctx.strokeText(MARK_CHAR, x, z);\n    ctx.fillText(MARK_CHAR, x, z);\n  }\n}\n\ninterface MapSign {\n  text: string;\n  x: number;\n  z: number;\n  size: number;\n}\n\nfunction putText(ctx: OffscreenCanvasRenderingContext2D, { text, x, z, size }: MapSign) {\n  ctx.lineWidth = Math.round(size * 0.2);\n  ctx.strokeStyle = \"rgba(0, 0, 0, 0.8)\";\n  ctx.strokeText(text, x, z);\n\n  ctx.lineWidth = Math.round(size * 0.1);\n  ctx.strokeStyle = \"white\";\n  ctx.strokeText(text, x, z);\n\n  ctx.fillText(text, x, z);\n}\n", "import { FontFaceSet } from \"css-font-loading-module\";\nimport MapRenderer from \"../lib/map-renderer\";\nimport { printError } from \"../lib/utils\";\n\ndeclare const fonts: FontFaceSet;\n\nexport type InMessage = Partial<\n  Pick<\n    MapRenderer,\n    | \"canvas\"\n    | \"biomesImg\"\n    | \"splat3Img\"\n    | \"splat4Img\"\n    | \"radImg\"\n    | \"biomesAlpha\"\n    | \"splat3Alpha\"\n    | \"splat4Alpha\"\n    | \"radAlpha\"\n    | \"showPrefabs\"\n    | \"brightness\"\n    | \"scale\"\n    | \"signSize\"\n    | \"signAlpha\"\n    | \"prefabs\"\n    | \"markerCoords\"\n  >\n>;\n\nexport interface OutMessage {\n  mapSize: GameMapSize;\n}\n\ndeclare function postMessage(message: OutMessage): void;\n\nconst FONT_FACE = new FontFace(\"Noto Sans\", \"url(../NotoEmoji-Regular.ttf)\");\n\nlet map: MapRenderer | null = null;\n\nFONT_FACE.load()\n  .then(() => {\n    fonts.add(FONT_FACE);\n    return map?.update();\n  })\n  .catch(printError);\n\nonmessage = async (event: MessageEvent<InMessage>) => {\n  const message = event.data;\n  console.debug(message);\n  if (!map) {\n    if (message.canvas) {\n      map = new MapRenderer(message.canvas, FONT_FACE);\n    } else {\n      throw Error(\"Unexpected state\");\n    }\n  }\n  await Object.assign(map, message).update();\n  postMessage({ mapSize: await map.size() });\n};\n"],
  "mappings": "mBAAO,SAASA,EAAkBC,EAAyBC,EAAe,IAAM,qBAAqB,OAAOD,CAAC,CAAC,GAAO,CACnH,GAAIA,GAAK,KAAM,OAAOA,EACjB,MAAM,MAAMC,EAAa,CAAC,CACjC,CA8BO,SAASC,GAAsC,CACpD,OAAO,IAAI,QAASC,GAAM,sBAAsBA,CAAC,CAAC,CACpD,CA+BA,eAAsBC,EAAqBC,EAAoC,CAC7E,IAAMC,EAAS,IAAI,gBAAgBD,EAAI,OAAQA,EAAI,KAAK,EAExD,OADgBE,EAAeD,EAAO,WAAW,IAAI,CAAC,EAC9C,UAAUD,EAAK,EAAG,CAAC,EACnB,MAAMC,EAAO,cAAc,CAAE,KAAM,WAAY,CAAC,CAC1D,CAMO,SAASE,EAAYC,EAAmD,CAC7E,MAAO,CAAE,KAAM,OAAQ,GAAGA,CAAE,CAC9B,CAyBO,SAASC,EAAWC,EAAkB,CAC3C,QAAQ,MAAMA,CAAC,CACjB,CCxGA,IAAMC,EAAe,IAERC,EAAN,KAAwB,CACrB,MACR,KACQ,IACA,gBAA+C,KAC/C,aAAe,EACf,OAER,YAAYC,EAAeC,EAAiCC,EAASJ,EAAc,CACjF,KAAK,MAAQE,EACTG,EAAUF,CAAQ,EACpB,KAAK,KAAOA,GAEZ,KAAK,KAAOG,EAAqBH,CAAQ,EACzC,KAAK,OAAOA,CAAQ,GAEtB,KAAK,OAASC,CAChB,CAEA,MAAM,KAA4B,CAChC,YAAK,aAAe,KAAK,IAAI,EACtB,KAAK,KAAO,KAAK,iBAAmB,KAAK,YAAY,CAC9D,CAEA,MAAc,aAAc,CAC1B,YAAK,gBAAkB,KAAK,eAAe,EACpC,KAAK,eACd,CAEA,MAAc,gBAAiB,CAC7B,QAAQ,MAAM,WAAY,KAAK,KAAK,EACpC,IAAMG,EAAM,MAAM,kBAAkB,MAAM,KAAK,IAAI,EACnD,YAAK,OAAOA,CAAG,EACf,KAAK,gBAAkB,KAChBA,CACT,CAEQ,OAAOA,EAAkB,CAC/B,KAAK,IAAMA,EACX,WAAW,IAAM,CACf,KAAK,YAAY,CACnB,EAAG,KAAK,MAAM,CAChB,CAEQ,aAAc,CAChB,KAAK,IAAI,EAAI,KAAK,aAAe,KAAK,QACxC,QAAQ,MAAM,SAAU,KAAK,KAAK,EAClCC,EAAe,KAAK,GAAG,EAAE,MAAM,EAC/B,KAAK,IAAM,MAEX,WAAW,IAAM,CACf,KAAK,YAAY,CACnB,EAAG,KAAK,MAAM,CAElB,CACF,EAEA,SAASH,EAAUI,EAAwC,CACzD,OAAOA,aAAa,IACtB,CC7DO,SAASC,EAAiBC,EAA4D,CAC3F,IAAMC,EAAkC,CAAC,EACzC,MAAO,IAAM,CACX,OAAQA,EAAe,OAAQ,CAC7B,IAAK,GAAG,CACN,IAAMC,GAAK,SAAY,CACrB,MAAMF,EAAU,EACXC,EAAe,MAAM,CAC5B,GAAG,EACH,OAAAA,EAAe,KAAKC,CAAC,EACdA,CACT,CACA,IAAK,GAAG,CACN,IAAMC,EAAOF,EAAe,CAAC,EACvBC,GAAK,SAAY,CACrB,MAAMC,EACN,MAAMC,EAAmB,EACzB,MAAMJ,EAAU,EACXC,EAAe,MAAM,CAC5B,GAAG,EACH,OAAAA,EAAe,KAAKC,CAAC,EACdA,CACT,CACA,IAAK,GAEH,OAAOD,EAAe,CAAC,EACzB,QACE,MAAM,MAAM,gCAAgCA,EAAe,OAAO,SAAS,CAAC,EAAE,CAClF,CACF,CACF,CC5BA,IAAMI,EAAY,SACZC,EAAY,kBAEGC,EAArB,KAAiC,CAC/B,WAAa,OACb,aAAkC,KAClC,MAAQ,GACR,YAAc,GACd,QAA+B,CAAC,EAChC,SAAW,IACX,UAAY,EACZ,YAAc,EACd,YAAc,EACd,YAAc,EACd,SAAW,EAEX,OAEA,OAASC,EAAiB,SAAY,CACpC,QAAQ,KAAK,WAAW,EACxB,MAAM,KAAK,kBAAkB,EAC7B,QAAQ,QAAQ,WAAW,CAC7B,CAAC,EAEO,WAAuC,KACvC,WAAuC,KACvC,WAAuC,KACvC,QAAoC,KACpC,SAER,YAAYC,EAAyBC,EAAoB,CACvD,KAAK,OAASD,EACd,KAAK,SAAWC,CAClB,CAEA,IAAI,UAAUC,EAAmC,CAC/C,KAAK,WAAaA,EAAM,IAAIC,EAAkB,SAAUD,CAAG,EAAI,IACjE,CACA,IAAI,UAAUA,EAAmC,CAC/C,KAAK,WAAaA,EAAM,IAAIC,EAAkB,SAAUD,CAAG,EAAI,IACjE,CACA,IAAI,UAAUA,EAAmC,CAC/C,KAAK,WAAaA,EAAM,IAAIC,EAAkB,SAAUD,CAAG,EAAI,IACjE,CACA,IAAI,OAAOA,EAAmC,CAC5C,KAAK,QAAUA,EAAM,IAAIC,EAAkB,MAAOD,CAAG,EAAI,IAC3D,CAEA,MAAM,MAA6B,CACjC,IAAME,EAAQ,MAAM,QAAQ,IAAI,CAAC,KAAK,YAAY,IAAI,EAAG,KAAK,YAAY,IAAI,EAAG,KAAK,YAAY,IAAI,CAAC,CAAC,EACxG,OAAOC,EAAY,CACjB,MAAO,KAAK,IAAI,GAAGD,EAAM,IAAKE,GAAMA,GAAG,OAAS,CAAC,CAAC,EAClD,OAAQ,KAAK,IAAI,GAAGF,EAAM,IAAKE,GAAMA,GAAG,QAAU,CAAC,CAAC,CACtD,CAAC,CACH,CAEQ,SAAmB,CACzB,MAAO,CAAC,KAAK,YAAc,CAAC,KAAK,YAAc,CAAC,KAAK,UACvD,CAEA,MAAM,mBAAmC,CACvC,GAAI,KAAK,QAAQ,EAAG,CAClB,KAAK,OAAO,MAAQ,EACpB,KAAK,OAAO,OAAS,EACrB,MACF,CAEA,GAAM,CAAE,MAAAC,EAAO,OAAAC,CAAO,EAAI,MAAM,KAAK,KAAK,EAE1C,KAAK,OAAO,MAAQD,EAAQ,KAAK,MACjC,KAAK,OAAO,OAASC,EAAS,KAAK,MAEnC,IAAMC,EAAU,KAAK,OAAO,WAAW,IAAI,EACtCA,IACLA,EAAQ,MAAM,KAAK,MAAO,KAAK,KAAK,EACpCA,EAAQ,OAAS,cAAc,KAAK,UAAU,IAE1C,KAAK,YAAc,KAAK,cAAgB,IAC1CA,EAAQ,YAAc,KAAK,YAC3BA,EAAQ,UAAU,MAAM,KAAK,WAAW,IAAI,EAAG,EAAG,EAAGF,EAAOC,CAAM,GAEhE,KAAK,YAAc,KAAK,cAAgB,IAC1CC,EAAQ,YAAc,KAAK,YAC3BA,EAAQ,UAAU,MAAM,KAAK,WAAW,IAAI,EAAG,EAAG,EAAGF,EAAOC,CAAM,GAEhE,KAAK,YAAc,KAAK,cAAgB,IAC1CC,EAAQ,YAAc,KAAK,YAC3BA,EAAQ,UAAU,MAAM,KAAK,WAAW,IAAI,EAAG,EAAG,EAAGF,EAAOC,CAAM,GAGpEC,EAAQ,OAAS,OACb,KAAK,SAAW,KAAK,WAAa,IACpCA,EAAQ,YAAc,KAAK,SAC3BA,EAAQ,sBAAwB,GAChCA,EAAQ,UAAU,MAAM,KAAK,QAAQ,IAAI,EAAG,EAAG,EAAGF,EAAOC,CAAM,EAC/DC,EAAQ,sBAAwB,IAGlCA,EAAQ,YAAc,KAAK,UACvB,KAAK,aACP,KAAK,YAAYA,EAASF,EAAOC,CAAM,EAErC,KAAK,cACP,KAAK,SAASC,EAASF,EAAOC,CAAM,EAExC,CAEQ,YAAYE,EAAwCH,EAAeC,EAAgB,CACzFE,EAAI,KAAO,GAAG,KAAK,SAAS,SAAS,CAAC,MAAM,KAAK,SAAS,MAAM,GAChEA,EAAI,UAAY,MAChBA,EAAI,UAAY,SAChBA,EAAI,aAAe,SAEnB,IAAMC,EAAUJ,EAAQ,EAClBK,EAAUJ,EAAS,EAEnBK,EAAc,KAAK,MAAM,KAAK,SAAW,GAAI,EAC7CC,EAAc,KAAK,MAAM,KAAK,SAAW,GAAI,EAGnD,QAAWC,KAAU,KAAK,QAAQ,WAAW,EAAG,CAC9C,IAAMC,EAAIL,EAAUI,EAAO,EAAIF,EAEzBI,EAAIL,EAAUG,EAAO,EAAID,EAC/BI,EAAQR,EAAK,CAAE,KAAMd,EAAW,EAAAoB,EAAG,EAAAC,EAAG,KAAM,KAAK,QAAS,CAAC,CAC7D,CACF,CAEQ,SAASP,EAAwCH,EAAeC,EAAgB,CACtF,GAAI,CAAC,KAAK,aAAc,OAExBE,EAAI,KAAO,GAAG,KAAK,SAAS,SAAS,CAAC,MAAM,KAAK,SAAS,MAAM,GAChEA,EAAI,UAAY,MAChBA,EAAI,UAAY,OAChBA,EAAI,aAAe,aAEnB,IAAMC,EAAUJ,EAAQ,EAClBK,EAAUJ,EAAS,EACnBK,EAAc,GAAK,KAAK,MAAM,KAAK,SAAW,GAAI,EAClDC,EAAc,GAAK,KAAK,MAAM,KAAK,SAAW,EAAG,EAEjDE,EAAIL,EAAU,KAAK,aAAa,EAAIE,EACpCI,EAAIL,EAAU,KAAK,aAAa,EAAIE,EAE1CI,EAAQR,EAAK,CAAE,KAAMb,EAAW,EAAAmB,EAAG,EAAAC,EAAG,KAAM,KAAK,QAAS,CAAC,EAC3DP,EAAI,WAAWb,EAAWmB,EAAGC,CAAC,EAC9BP,EAAI,SAASb,EAAWmB,EAAGC,CAAC,CAC9B,CACF,EASA,SAASC,EAAQR,EAAwC,CAAE,KAAAS,EAAM,EAAAH,EAAG,EAAAC,EAAG,KAAAG,CAAK,EAAY,CACtFV,EAAI,UAAY,KAAK,MAAMU,EAAO,EAAG,EACrCV,EAAI,YAAc,qBAClBA,EAAI,WAAWS,EAAMH,EAAGC,CAAC,EAEzBP,EAAI,UAAY,KAAK,MAAMU,EAAO,EAAG,EACrCV,EAAI,YAAc,QAClBA,EAAI,WAAWS,EAAMH,EAAGC,CAAC,EAEzBP,EAAI,SAASS,EAAMH,EAAGC,CAAC,CACzB,CCzIA,IAAMI,EAAY,IAAI,SAAS,YAAa,+BAA+B,EAEvEC,EAA0B,KAE9BD,EAAU,KAAK,EACZ,KAAK,KACJ,MAAM,IAAIA,CAAS,EACZC,GAAK,OAAO,EACpB,EACA,MAAMC,CAAU,EAEnB,UAAY,MAAOC,GAAmC,CACpD,IAAMC,EAAUD,EAAM,KAEtB,GADA,QAAQ,MAAMC,CAAO,EACjB,CAACH,EACH,GAAIG,EAAQ,OACVH,EAAM,IAAII,EAAYD,EAAQ,OAAQJ,CAAS,MAE/C,OAAM,MAAM,kBAAkB,EAGlC,MAAM,OAAO,OAAOC,EAAKG,CAAO,EAAE,OAAO,EACzC,YAAY,CAAE,QAAS,MAAMH,EAAI,KAAK,CAAE,CAAC,CAC3C",
  "names": ["requireNonnull", "t", "errorMessage", "waitAnimationFrame", "r", "imageBitmapToPngBlob", "img", "canvas", "requireNonnull", "gameMapSize", "s", "printError", "e", "IMG_AGE_MSEC", "ImageBitmapHolder", "label", "original", "imgAge", "isPngBlob", "imageBitmapToPngBlob", "img", "requireNonnull", "o", "throttledInvoker", "asyncFunc", "workerPromises", "p", "prev", "waitAnimationFrame", "SIGN_CHAR", "MARK_CHAR", "MapRenderer", "throttledInvoker", "canvas", "fontFace", "img", "ImageBitmapHolder", "rects", "gameMapSize", "r", "width", "height", "context", "ctx", "offsetX", "offsetY", "charOffsetX", "charOffsetY", "prefab", "x", "z", "putText", "text", "size", "FONT_FACE", "map", "printError", "event", "message", "MapRenderer"]
}
