"use strict";(()=>{function k(){return new Promise(r=>requestAnimationFrame(r))}function f(r){console.error(r)}async function g(r){return await(await fetch(r)).json()}function x(r){let t=[];return()=>{switch(t.length){case 0:{let e=(async()=>{await r(),t.shift()})();return t.push(e),e}case 1:{let e=t[0],s=(async()=>{await e,await k(),await r(),t.shift()})();return t.push(s),s}case 2:return t[1];default:throw Error(`Unexpected state: promiceses=${t.length.toString()}`)}}}var E={en:"english",de:"german",es:"spanish",fr:"french",it:"italian",ja:"japanese",ko:"koreana",pl:"polish",pt:"brazilian",ru:"russian",tr:"turkish","zh-CN":"schinese","zh-TW":"tchinese"},L=["blocks","prefabs","shapes"],h=class r{static DEFAULT_LANGUAGE="english";#e;#t;#s;#r;constructor(t,e){this.#e=t,this.#t=v(e),this.#s=new Map(L.map(s=>[s,this.#i(r.DEFAULT_LANGUAGE,s)])),this.#r=this.#n()}get(t){let e=this.#r.get(t);if(!e)throw new Error(`No labels for ${this.#t}/${t}`);return e}set language(t){t!==this.#t&&(console.log("LabelHolder set language: %s -> %s",this.#t,t),this.#t=t,this.#r=this.#n())}#n(){return new Map(L.map(t=>[t,this.#a(t)]))}async#a(t){let e=this.#s.get(t);if(!e)throw new Error(`No fallback for ${this.#t}/${t}`);return new p(await this.#i(this.#t,t),await e)}async#i(t,e){return new Map(Object.entries(await g(`${this.#e}/${t}/${e}.json`)))}},p=class{#e;#t;constructor(t,e){this.#e=t,this.#t=e}get(t){return this.#e.get(t)??this.#t.get(t)}};function v(r){for(let t of r)for(let[e,s]of Object.entries(E))if(t.startsWith(e))return s;return h.DEFAULT_LANGUAGE}var c=class{all=[];filtered=[];markCoords=null;status="";#e={};#t;filter;throttledUpdater=x(()=>this.updateImmediately());updateListeners=[];constructor(t,e){this.#t=new h(t,e),this.filter=this.defaultMatcher()}set language(t){this.#t.language=t}set prefabsFilterString(t){let e=t.trim();e.length===0?this.filter=this.defaultMatcher():/^ðŸ’€\d+$/.test(e)?this.filter=new w(parseInt(e.slice(2),10),this.#t):this.filter=new P(new RegExp(e,"i"),this.#t)}set blocksFilterString(t){let e=t.trim();e.length===0?this.filter=this.defaultMatcher():this.filter=new l(new RegExp(e,"i"),this.#e,this.#t)}set blockPrefabCounts(t){this.#e=t,this.filter instanceof l&&(this.filter=new l(this.filter.regexp,t,this.#t))}update(){this.throttledUpdater().catch(f)}async updateImmediately(){await this.applyFilter(),this.updateDist(),this.sort();let t={status:this.status,prefabs:this.filtered};this.updateListeners.forEach(e=>{e(t)})}addUpdateListener(t){this.updateListeners.push(t)}defaultMatcher(){return new b(this.#t)}async applyFilter(){let t=await this.filter.match(this.all);this.status=t.status,this.filtered=t.matched}updateDist(){if(this.markCoords){let{markCoords:t}=this;this.filtered.forEach(e=>e.dist=C(e,t))}else this.filtered.forEach(t=>t.dist=null)}sort(){this.markCoords?(this.status=`${this.status}, order by distances from the flag`,this.filtered.sort(y)):this.filter instanceof l?(this.status=`${this.status}, order by counts of matched blocks`,this.filtered.sort(M)):this.filtered.sort(u)}};function u(r,t){return r.name>t.name?1:r.name<t.name?-1:0}function M(r,t){if(!r.matchedBlocks||!t.matchedBlocks)return u(r,t);let e=r.matchedBlocks.reduce((n,i)=>n+(i.count??0),0),s=t.matchedBlocks.reduce((n,i)=>n+(i.count??0),0);return e<s?1:e>s?-1:u(r,t)}function y(r,t){return!r.dist||!t.dist?u(r,t):r.dist>t.dist?1:r.dist<t.dist?-1:u(r,t)}function C(r,t){return Math.round(Math.sqrt((r.x-t.x)**2+(r.z-t.z)**2))}function d(r,t){let e=!1,s=r.replace(t,n=>(e=n.length>0,`<mark>${n}</mark>`));return e?s:null}var b=class{labels;constructor(t){this.labels=t}async match(t){let e=await this.labels.get("prefabs");return{status:t.length===0?"No prefabs":"All prefabs",matched:t.map(s=>{let n=e.get(s.name)??"-";return{...s,highlightedName:s.name,highlightedLabel:n}})}}},P=class{regexp;labels;constructor(t,e){this.regexp=t,this.labels=e}async match(t){let e=await this.labels.get("prefabs"),s=t.flatMap(n=>{let i=d(n.name,this.regexp),a=e.get(n.name)??"-",o=a&&d(a,this.regexp);return i??o?{...n,highlightedName:i??n.name,highlightedLabel:o??a}:[]});return{status:`${s.length.toString()} matched prefabs`,matched:s}}},l=class{regexp;#e;labels;constructor(t,e,s){this.regexp=t,this.#e=e,this.labels=s}async match(t){let e=await this.matchBlocks();if(e.length===0)return{status:"No matched blocks",matched:[]};let s=this.matchPrefabTypes(e);if(Object.keys(s).length===0)return{status:`No prefabs, but ${e.length.toString()} matched blocks`,matched:[]};let n=await this.labels.get("prefabs"),i=t.flatMap(a=>{let o=s[a.name];return o?{...a,highlightedName:a.name,highlightedLabel:n.get(a.name)??"-",matchedBlocks:o}:[]});return{status:`${i.length.toString()} prefabs, ${e.length.toString()} matched blocks`,matched:i}}async matchBlocks(){let t=await this.labels.get("blocks"),e=await this.labels.get("shapes");return Object.entries(this.#e).flatMap(([s,n])=>{let i=d(s,this.regexp),a=t.get(s)??e.get(s)??"-",o=a&&d(a,this.regexp);return i??o?{name:s,highlightedName:i??s,highlightedLabel:o??a,prefabs:n}:[]})}matchPrefabTypes(t){return t.reduce((e,s)=>{if(!s.prefabs)return e;for(let[n,i]of Object.entries(s.prefabs))e[n]=(e[n]??[]).concat({...s,count:i});return e},{})}},w=class{constructor(t,e){this.difficulty=t;this.labels=e;this.difficulty=t}async match(t){if(isNaN(this.difficulty)||this.difficulty<1||this.difficulty>5)return Promise.resolve({status:`Invalid difficulty tier: ${this.difficulty.toString()}`,matched:[]});let e=await this.labels.get("prefabs"),s=t.flatMap(n=>{if(n.difficulty!==this.difficulty)return[];let i=e.get(n.name)??"-";return{...n,highlightedName:n.name,highlightedLabel:i}});return{status:`${s.length.toString()} prefabs with difficulty tier ${this.difficulty.toString()}`,matched:s}}};var m=new c("../labels",navigator.languages);(async()=>{m.blockPrefabCounts=T(await g("../prefab-block-counts.json")),m.update()})().catch(f);onmessage=({data:r})=>{console.log("Prefab-filter received message: ",r),Object.assign(m,r).update()};m.addUpdateListener(r=>{console.log("Prefab-filter send message: ",r),postMessage(r)});function T(r){let t={};for(let[e,s]of Object.entries(r))for(let[n,i]of Object.entries(s))t[n]=Object.assign(t[n]??{},{[e]:i});return t}})();
//# sourceMappingURL=prefabs-filter.js.map
