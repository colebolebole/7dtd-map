{
  "version": 3,
  "sources": ["../../src/lib/utils.ts", "../../src/lib/labels.ts", "../../src/lib/label-handler.ts", "../../src/prefabs/main.ts"],
  "sourcesContent": ["export function requireNonnull<T>(t: T | undefined | null, errorMessage = () => `Unexpected state: ${String(t)}`): T {\n  if (t == null) throw Error(errorMessage());\n  return t;\n}\n\nexport function strictParseInt(s: string | undefined | null, errorMessage = () => `Unexpected argument: ${String(s)}`): number {\n  const n = parseInt(s ?? \"\");\n  if (isNaN(n)) throw Error(errorMessage());\n  return n;\n}\n\nexport function requireType<T>(o: unknown, t: new (...a: unknown[]) => T, errorMessage = () => `Unexpected type: ${String(o)}`): T {\n  if (o instanceof t) return o;\n  throw Error(errorMessage());\n}\n\nexport function component<T extends HTMLElement = HTMLElement>(id: string | undefined | null, t?: new (...a: unknown[]) => T): T {\n  const i = requireNonnull(id, () => \"Unexpected argument: id is null\");\n  const e = requireNonnull(document.getElementById(i), () => `Element not found: #${i}`);\n  return t ? requireType(e, t) : (e as T);\n}\n\nexport function removeAllChildren(e: HTMLElement): void {\n  while (e.lastChild) e.removeChild(e.lastChild);\n}\n\nexport function humanreadableDistance(d: number): string {\n  if (d < 1000) {\n    return `${d.toString()}m`;\n  }\n  return `${(d / 1000).toFixed(2)}km`;\n}\n\nexport function waitAnimationFrame(): Promise<number> {\n  return new Promise((r) => requestAnimationFrame(r));\n}\n\ninterface EventOffsets {\n  offsetX: number;\n  offsetY: number;\n}\n\nexport function formatCoords(\n  map: GameMapSize,\n  canvas: HTMLCanvasElement,\n  elevation: (coods: GameCoords, mapSize: GameMapSize) => number | null,\n  event: EventOffsets | null,\n): string {\n  if (!event) return \"E/W: -, N/S: -, Elev: -\";\n\n  const gameCoords = canvasEventToGameCoords(event, map, canvas);\n  if (gameCoords === null) {\n    return \"E/W: -, N/S: -, Elev: -\";\n  }\n\n  const y = elevation(gameCoords, map) ?? \"-\";\n  return `E/W: ${gameCoords.x.toString()}, N/S: ${gameCoords.z.toString()}, Elev: ${y.toString()}`;\n}\n\nexport function downloadCanvasPng(fileName: string, canvas: HTMLCanvasElement): void {\n  const a = document.createElement(\"a\");\n  a.download = fileName;\n  a.href = canvas.toDataURL(\"image/png\");\n  a.click();\n}\n\nlet imageBitmapToPngBlobCount = 0;\nexport async function imageBitmapToPngBlob(img: ImageBitmap): Promise<PngBlob> {\n  const count = imageBitmapToPngBlobCount++;\n  console.time(`imageBitmapToPngBlob ${count.toString()}`);\n  const canvas = new OffscreenCanvas(img.height, img.width);\n  const context = requireNonnull(canvas.getContext(\"2d\"));\n  context.drawImage(img, 0, 0);\n  const b = (await canvas.convertToBlob({ type: \"image/png\" })) as PngBlob;\n  console.timeEnd(`imageBitmapToPngBlob ${count.toString()}`);\n  console.debug(\"imageBitmapToPngBlob png %d KB\", b.size / 1000);\n  return b;\n}\n\nexport async function sleep(msec: number): Promise<void> {\n  return new Promise((r) => setTimeout(r, msec));\n}\n\nexport function gameMapSize(s: { width: number; height: number }): GameMapSize {\n  return { type: \"game\", ...s };\n}\n\nexport function gameCoords(c: { x: number; z: number }): GameCoords {\n  return { type: \"game\", ...c };\n}\n\n/** Returns null if the event was fired out of the canvas */\nexport function canvasEventToGameCoords(event: EventOffsets, mapSize: GameMapSize, canvasSize: HTMLCanvasElement): GameCoords | null {\n  // in-game scale coords with left-top offset\n  const gx = (event.offsetX * mapSize.width) / canvasSize.width;\n  const gz = (event.offsetY * mapSize.height) / canvasSize.height;\n  if (gx < 0 || gx >= mapSize.width || gz < 0 || gz >= mapSize.height) {\n    return null;\n  }\n\n  // in-game coords (center offset)\n  const x = gx - Math.floor(mapSize.width / 2);\n  const z = Math.floor(mapSize.height / 2) - gz;\n  return gameCoords({ x: Math.round(x), z: Math.round(z) });\n}\n\nexport function threePlaneSize(width: number, height: number): ThreePlaneSize {\n  return { type: \"threePlane\", width, height };\n}\n\nexport function printError(e: unknown): void {\n  console.error(e);\n}\n\nexport async function fetchJson<T>(url: string): Promise<T> {\n  return (await (await fetch(url)).json()) as T;\n}\n\nexport async function invokeAll<T>(fns: ((t: T) => unknown)[], t: T): Promise<void> {\n  await Promise.all(fns.map((fn) => fn(t)));\n}\n", "import { fetchJson } from \"./utils\";\n\nexport const LANGUAGES = [\n  \"english\",\n  \"german\",\n  \"spanish\",\n  \"french\",\n  \"italian\",\n  \"japanese\",\n  \"koreana\",\n  \"polish\",\n  \"brazilian\",\n  \"russian\",\n  \"turkish\",\n  \"schinese\",\n  \"tchinese\",\n] as const;\nexport type Language = (typeof LANGUAGES)[number];\n\nconst LANGUAGE_TAGS: { [tag: string]: Language } = {\n  en: \"english\",\n  de: \"german\",\n  es: \"spanish\",\n  fr: \"french\",\n  it: \"italian\",\n  ja: \"japanese\",\n  ko: \"koreana\",\n  pl: \"polish\",\n  pt: \"brazilian\",\n  ru: \"russian\",\n  tr: \"turkish\",\n  \"zh-CN\": \"schinese\",\n  \"zh-TW\": \"tchinese\",\n};\n\nconst FILE_BASE_NAMES = [\"blocks\", \"prefabs\", \"shapes\"] as const;\ntype FileBaseName = (typeof FILE_BASE_NAMES)[number];\n\nexport class LabelHolder {\n  static DEFAULT_LANGUAGE: Language = \"english\";\n\n  #baseUrl: string;\n  #language: Language;\n  #fallbacks: Map<FileBaseName, Promise<Map<string, string>>>;\n  #labels: Map<FileBaseName, Promise<Labels>>;\n\n  constructor(baseUrl: string, navigatorLanguages: readonly string[]) {\n    this.#baseUrl = baseUrl;\n    this.#language = resolveLanguage(navigatorLanguages);\n    this.#fallbacks = new Map(FILE_BASE_NAMES.map((n) => [n, this.#fetchLabelMap(LabelHolder.DEFAULT_LANGUAGE, n)] as const));\n    this.#labels = this.#buildAllLabels();\n  }\n\n  get(fileId: FileBaseName): Promise<Labels> {\n    const labels = this.#labels.get(fileId);\n    if (!labels) throw new Error(`No labels for ${this.#language}/${fileId}`);\n    return labels;\n  }\n\n  set language(lang: Language) {\n    if (lang === this.#language) return;\n    console.log(\"LabelHolder set language: %s -> %s\", this.#language, lang);\n    this.#language = lang;\n    this.#labels = this.#buildAllLabels();\n  }\n\n  #buildAllLabels(): Map<FileBaseName, Promise<Labels>> {\n    return new Map(FILE_BASE_NAMES.map((n) => [n, this.#buildLabels(n)]));\n  }\n\n  async #buildLabels(fileBaseName: FileBaseName): Promise<Labels> {\n    const fallback = this.#fallbacks.get(fileBaseName);\n    if (!fallback) throw new Error(`No fallback for ${this.#language}/${fileBaseName}`);\n    return new Labels(await this.#fetchLabelMap(this.#language, fileBaseName), await fallback);\n  }\n\n  async #fetchLabelMap(language: Language, fileId: FileBaseName): Promise<Map<string, string>> {\n    return new Map(Object.entries(await fetchJson(`${this.#baseUrl}/${language}/${fileId}.json`)));\n  }\n}\n\nexport class Labels {\n  #labels: Map<string, string>;\n  #fallback: Map<string, string>;\n\n  constructor(labels: Map<string, string>, defaultLabels: Map<string, string>) {\n    this.#labels = labels;\n    this.#fallback = defaultLabels;\n  }\n\n  get(key: string): string | undefined {\n    return this.#labels.get(key) ?? this.#fallback.get(key);\n  }\n}\n\nexport function resolveLanguage(languages: readonly string[]): Language {\n  for (const clientTag of languages) {\n    for (const [tag, lang] of Object.entries(LANGUAGE_TAGS)) {\n      if (clientTag.startsWith(tag)) return lang;\n    }\n  }\n  return LabelHolder.DEFAULT_LANGUAGE;\n}\n", "import { LANGUAGES, Language, resolveLanguage } from \"./labels\";\nimport { printError } from \"./utils\";\n\ninterface Doms {\n  language: HTMLSelectElement;\n}\n\nexport class LabelHandler {\n  private doms: Doms;\n  private listener: ((lang: Language) => void | Promise<void>)[] = [];\n\n  constructor(doms: Doms, navigatorLanguages: readonly string[]) {\n    this.doms = doms;\n    this.buildSelectOptions(navigatorLanguages);\n    this.doms.language.addEventListener(\"change\", () => {\n      this.listener.forEach((fn) => {\n        fn(this.doms.language.value as Language)?.catch(printError);\n      });\n    });\n  }\n\n  private buildSelectOptions(navigatorLanguages: readonly string[]) {\n    const existingLangs = new Set(Array.from(this.doms.language.options).map((o) => o.value));\n    for (const lang of LANGUAGES) {\n      if (existingLangs.has(lang)) {\n        continue;\n      }\n      const option = document.createElement(\"option\");\n      option.textContent = lang;\n      this.doms.language.appendChild(option);\n    }\n\n    const browserLang = resolveLanguage(navigatorLanguages);\n    if (this.doms.language.value !== browserLang) {\n      this.doms.language.value = resolveLanguage(navigatorLanguages);\n      requestAnimationFrame(() => this.doms.language.dispatchEvent(new Event(\"change\")));\n    }\n  }\n\n  addListener(fn: (lang: Language) => void | Promise<void>) {\n    this.listener.push(fn);\n  }\n}\n", "import { LabelHandler } from \"../lib/label-handler\";\nimport { LabelHolder, Labels } from \"../lib/labels\";\nimport { component } from \"../lib/utils\";\n\nfunction main() {\n  const labelHolder = new LabelHolder(\"../labels\", navigator.languages);\n  const labelHandler = new LabelHandler({ language: component(\"label_lang\", HTMLSelectElement) }, navigator.languages);\n  labelHandler.addListener(async (lang) => {\n    labelHolder.language = lang;\n    updatePrefabLabels(await labelHolder.get(\"prefabs\"));\n    udpateBlockLabels(await labelHolder.get(\"blocks\"), await labelHolder.get(\"shapes\"));\n  });\n}\n\nfunction updatePrefabLabels(labels: Labels) {\n  const name = document.querySelector(\".prefab_name\")?.textContent?.trim();\n  if (!name) return;\n  const labelEl = document.querySelector(\".prefab_label\");\n  if (!labelEl) return;\n  labelEl.textContent = labels.get(name) ?? \"-\";\n}\n\nfunction udpateBlockLabels(blockLabels: Labels, shapeLabels: Labels) {\n  for (const blockEl of component(\"blocks\", HTMLElement).querySelectorAll(\".block\")) {\n    const name = blockEl.querySelector(\".block_name\")?.textContent?.trim();\n    if (!name) continue;\n    const labelEl = blockEl.querySelector(\".block_label\");\n    if (!labelEl) continue;\n    labelEl.textContent = blockLabels.get(name) ?? shapeLabels.get(name) ?? \"-\";\n  }\n}\n\nif (document.readyState === \"loading\") {\n  document.addEventListener(\"DOMContentLoaded\", main);\n} else {\n  main();\n}\n"],
  "mappings": "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",
  "names": ["requireNonnull", "t", "errorMessage", "requireType", "o", "t", "errorMessage", "component", "id", "i", "requireNonnull", "e", "printError", "e", "fetchJson", "url", "LANGUAGES", "LANGUAGE_TAGS", "FILE_BASE_NAMES", "LabelHolder", "_LabelHolder", "#baseUrl", "#language", "#fallbacks", "#labels", "baseUrl", "navigatorLanguages", "resolveLanguage", "n", "#fetchLabelMap", "#buildAllLabels", "fileId", "labels", "lang", "#buildLabels", "fileBaseName", "fallback", "Labels", "language", "fetchJson", "#fallback", "defaultLabels", "key", "languages", "clientTag", "tag", "LabelHandler", "doms", "navigatorLanguages", "fn", "printError", "existingLangs", "lang", "LANGUAGES", "option", "browserLang", "resolveLanguage", "main", "labelHolder", "LabelHolder", "LabelHandler", "component", "lang", "updatePrefabLabels", "udpateBlockLabels", "labels", "name", "labelEl", "blockLabels", "shapeLabels", "blockEl"]
}
